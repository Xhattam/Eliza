#!/bin/env python
# -*- coding: utf-8 -*-

import time
import random
import Tkinter
import re
import stack


"""
Created on Tue Apr 23 10:36:29 2013

@author: BAbemonty, MChassang, KKiranova, JTanon
"""
class eliza():
    
    """
    The core class of Eliza that contains all the fundamental functions.
    """

    def __init__(self):
        
        """
        creates an instance of Eliza
        
        fields:
        String self.input                -   user entry from GUI
        str-List self.tokenInput         -   token list from user input   
        str-List self.subjectInput       -   token list for subject
        str-List self.objectInput        -   token list for object
        String self.verb                 -   identified verb
        str-Tuple self.verbtuple         -   tuple (infinitive + flexion)
        tuple-List self.stack            -   stack of keywords (Eliza's memory)
        String self.output               -   calculated answer (to be sent back to GUI)  
        String refl_pro                  -   identified reflexive pronoun
        boolean neg                      -   negative/positive status of the input
        dict self.myPronouns             -   pronouns dictionary
        dict self.talkToMeMore           -   random sentence (if self.output is empty)
        dict self.psychoVerbs            -   psychological verbs dictionary
        dict self.allMyKeywords          -   keywords dictionary
        String file_lefff                -   the name of the text file containing LEFFF

        """


        
        self.input = ""
        self.tokenInput = []
        self.subjectInput = []
        self.objectInput = []
        self.verb = ""
        self.verbtuple = []
        self.stack = stack()
        self.output = "" 
        self.refl_pro = "" 
        self.neg = False 
        self.myPronouns = myPronouns
        self.talkToMeMore = talkToMeMore
        self.psychoVerbs = psychoVerbs
        self.allMyKeywords = allMyKeywords
        self.reflexive = reflexive
        self.file_lefff = "Lefff.txt"
        
    
    
    def setInput(self, text):
        """
        passes a string to Eliza as input
        :param text: user entry
        """
        self.input = text.encode('utf-8')
        
        
    def tokenize (self, entry):
        """
        tokenizes a string (divides a text by words)
        :param entry: input phrase (user entry)
        :returns: a list of words
        """
        
        s = entry
        token_list = []
        f = 1 # end of the token
        d = 0 # first symbol of the token
        elision = ['c', 'd', 'j', 'l', 'm', 'n', 's', 't'] # short words elided before an apostrophe, like me - m', ce - c'
        ponct = ['.', ',', '!', '?', ';', ':', '"', '(', ')', '[', ']']
        while f < len(s):
            word = "" # the next token
            sponct = "" # the next punctuation mark
            if(s[f] == " "):
                word = s[d:f]
                f += 1
                d = f
            elif(s[f] in ponct):
                sponct = s[f]
                word = s[d:f]
                if(f+1 < len(s)and s[f+1] == " "):
                    f += 2
                else:
                    f += 1
                d = f
            elif(s[f] == "'"): # if there's an apostrophe, it can be one word or two
                if(s[f-1].lower() in elision):
                    if(f-1 == 0): # first symbol of the phrase : it is an elided word
                        word = s[d:f+1]
                        f += 1
                        d = f
                    elif(s[f-2] ==" "): # first symbol of the word : it is an elided word
                        word = s[d:f+1]
                        f += 1
                        d = f
                    else: # it is a word with an apostrophe in the middle (like "aujourd'hui")
                        f += 1
                else: # not a lettre from the elision list : it is a word with an apostrophe in the middle
                    f += 1
            else:
                f += 1
            
            if(word != ""):
                token_list.append(word)
            if(sponct != ""):
                token_list.append(sponct)
                
        if(d != len(s)): # if the last word is not in the token list, add it
            word = s[d:]
            token_list.append(word)
        
        if token_list[-1] in ponct:
            token_list = token_list[:-1] # cut the punctuation mark in the end of the phrase
        
        self.tokenInput = token_list
        return self.tokenInput
          
    
    def negation (self, text):
        """
        determines if the phrase is negative or positive
        :param text: phrase in the input
        """
        lst1 = ["jamais", "rien", "ne", "n\'", "ni"]
        
        lst2 = ["pas", "plus", "point"]
        
        for e in text:
            if e in lst1 :
                return True
            elif e in lst2:
                for elem  in lst1:
                    if elem in text:
                        return True
        return False
    
    
    def tagging(self): 
        """
        identifies the main verb, the subject and the object of the phrase
        """
       
        lst = self.tokenInput
        
              
        for elem in range(len(lst)): # looks for keywords in the phrase. If found, adds them to the stack(memory) 
            if elem > 0: # first element has no DET so it cannot form a tuple (det+noun)
                for i in self.allMyKeywords.keys():
                    if re.match(i, lst[elem]): # search with regex in the keywords 
                        self.stackWrite(lst[elem-1:elem+1])
        
        # verb identification
        
        posVerb = len(lst)-1 # the position of the verb, by default it is the last word in the phrase
  
                        
        if self.verb == "": # looking for the verb form in LEFFF
            lefff = self.split_lefff()
            for e in range(len(lst)):
                if lst[e] not in ['tu', 'lui']: # homonymous with past participle of verbs "taire" et "luire"
                    in_lefff = self.recup_inf(lefff, lst[e], lst[:e])
                    if in_lefff != 0: # if verb form found in LEFFF
                        self.verb = lst[e]
                        self.verbtuple = in_lefff # infinitive form  + flexion of the verb
                        posVerb = e
                        
                        # search for minimal context
                        
                        if self.verbtuple[0] in self.psychoVerbs: # if the verb is psychologically marked, use one of the precomposed answers
                            if self.neg: 
                                if self.psychoVerbs[self.verbtuple[0]] == 'NegFear':
                                    if self.verbtuple[0] in ['paniquer', 'angoisser', 'stresser']:  
                                        lst = ["Faire preuve de self-contrôle est une bonne chose! Continuez, je voudrais en savoir plus sur ce sujet.", 
                                        "Prendre les choses calmement, voilà une bonne approche! Dites m'en plus.", 
                                        "Savoir prendre les choses du bon côté est une vertu. Dites m'en plus!"]
                                    else:
                                        lst = ["C'est plutôt une bonne chose, non?", "Etes-vous d'acord pour dire que c'est une bonne chose?"
                                        "Pensez-vous que ce soit une mauvaise chose ?"]
                                    self.output = random.choice(lst)
                                    return self.output

                                elif self.psychoVerbs[self.verbtuple[0]] == 'NegSad':
                                    lst = ["C'est plutôt une bonne chose, ne pensez-vous pas ?", "C'est bien! Dites-m'en plus!"]
                                    self.output = random.choice(lst)
                                    return self.output
                                
                                elif self.psychoVerbs[self.verbtuple[0]] == 'Love':
                                    lst = ["C'est un peu triste, pourquoi donc ?", "Pourriez-vous me dire pourquoi ?", 
                                    "Pensez-vous que ceci est lié à une mauvaise expérience passée ?"]
                                    self.output = random.choice(lst)
                                    return self.output

                                else:
                                    lst = ["Je vois. Ce n'est pas non plus le grand amour cependant, pourriez-vous me dire pourquoi  ?",
                                    "D'accord, le sentiment n'est pas complètement négatif. Pourquoi pas simplement positif ? ", 
                                    "C'est mieux que rien! N'êtes-vous pas d'accord ?"]
                                    self.output = random.choice(lst)
                                    return self.output

                            else:             
                                if self.psychoVerbs[self.verbtuple[0]] == 'NegFear':
                                    if self.verbtuple[0] in ['paniquer', 'angoisser', 'stresser']:  
                                        lst = ["Decrivez-moi précisement vos sentiments à ce sujet, que ressentez-vous vraiment ?", 
                                        "Pourquoi vous sentez-vous mal par rapport à cela ?", "Qu'est-ce que cela fait ressurgir chez vous ?"]
                                    else:
                                        lst = ["Pourquoi faire cela ? Qu'est-ce que ça vous apporte ?", "Pourquoi faire cela ? Est-ce que ça vous amuse ?",
                                        "J'aimerais comprendre vos motivations, pourquoi agir ainsi ?"]
                                    self.output = random.choice(lst)
                                    return self.output

                                elif self.psychoVerbs[self.verbtuple[0]] == 'NegSad':
                                    lst = ["Je suis desolée d'apprendre cela, continuez, parler vous aidera.",
                                    "Je comprends... Dans ce cas, ne gardez pas ça pour vous, racontez-moi l'histoire."
                                    "Continuez, garder ceci pour vous ne vous aidera pas, je suis là pour vous aider."]
                                    self.output = random.choice(lst)
                                    return self.output
                                
                                elif self.psychoVerbs[self.verbtuple[0]] == 'Love':
                                    lst = ["C'est un sentiment plutôt positif! Continuez!", "Je comprends, c'est un bon sentiment! Dites m'en plus!",
                                    "Très bien, ne vous arrêtez pas en si bon chemin, c'est une idée positive!"]
                                    self.output = random.choice(lst)
                                    return self.output

                                else:
                                    lst = ["Pourquoi un sentiment aussi négatif ?", "J'aimerais comprendre l'origine de ce sentiment négatif, cotinuez s'il vous plait.",
                                    "Comment se fait-il que vous ayez une opinion si négative ?", "Expliquez-moi ce qui ne va pas."]
                                    self.output = random.choice(lst)
                                    return self.output
                      
                        if e > 1: # if there are at least 2 words before the verb, there can be a reflexive pronoun
                            if lst[e-1] in self.reflexive.keys():
                                if lst[e-1] == 'nous': # the pronouns "nous" and "vous" are considered reflexive only if there is another "nous" or "vous" in the phrase
                                    for i in range(0,e-1):
                                        if lst[i] == 'nous':
                                            self.refl_pro = 'vous' # inversion of the reflexive pronoun
                                elif lst[e-1] == 'vous':
                                    for i in range(0,e-1):
                                        if lst[i] == 'vous':
                                            self.refl_pro = 'nous' # inversion of the reflexive pronoun
                                else:
                                    self.refl_pro = self.reflexive[lst[e-1]] # inversion of the reflexive pronoun
                        break
           
        # subject identification
        
        subjectScope = lst[:posVerb] # all the part of the phrase before the verb may be the subject (example : "Ma petite fille blonde est venue")
        ponct = ['.', ',', '!', '?', ';', ':']
        newScope = subjectScope # we consider as subject only the part of the phrase after the punctuation marks
        
        for i in range(len(subjectScope)):
            if subjectScope[i] in ponct:
                if i+1 < len(subjectScope):
                    newScope = subjectScope[i+1:]
                else:
                    newScope = []
        
        subjectScope = newScope
                
        if len(subjectScope) > 0:
            self.subjectInput = self.searchSubject(subjectScope)
        
        
        # object identification
    
        idx = posVerb + 1
        while idx < len(lst) and lst[idx] not in ['.', '!', '?', ';', ':']:
            self.objectInput.append(lst[idx]) # the object is the part of the phrase between the verb and the end of the phrase
            idx += 1
        

    def searchSubject(self, subjectScope):
        """
        search for subject in the text given
        :param subjectScope: the first part of the phrase (a token list)
        :returns: the subject of the phrase
        """
        lstPro = ['je$', 'tu$', 'ils?$', 'j\'$', 'elles?$', 'on$', 'ça$'] # these words before the verb are always subjects
        for e in subjectScope:
            for pro in lstPro:
                if re.match(pro, e):
                    self.subjectInput.append(e)
                    return self.subjectInput
        
        return self.searchDet(subjectScope)

    
    def searchDet(self, subjectScope):
        """
        search for a couple DET+noun in the text given
        :param subjectScope: the first part of the phrase (a token list)
        :returns: the subject of the phrase
        """
        length = len(subjectScope)-1
        elem = subjectScope[length] # the word just before the verb (last word of subjectScope)
        pronouns = ['c\'', 'l\'', 'm\'', 'n\'', 's\'', 't\'', 'me', 'te', 'se', 'ne', 'la', 'le', 'les'] # words that can precede the verb but should not be in the subject
        lstDet = ['les?$', 'la$', 'une?$', 'des$', 'l\'$', 'mon$', 'ton$',
        'son$', 'ma$', 'ta$', 'sa$', 'mes$', 'tes$', 'ses$', 'nos$', 'vos$', 'leurs?$',
        'notre$', 'votre$', 'ce.{0,3}$', 'deux$', 'trois$', 'quatre$', 'cinq$', 'aucun.*',
        'tel.*', 'quelques?$', 'certain.*', 'divers.*', 'tou.{1,3}$']

        for e in range(len(subjectScope)):
            for det in lstDet:
                if re.match(det, subjectScope[e]):
                    if elem in pronouns:
                        self.subjectInput = subjectScope[e:length]
                    else:
                        self.subjectInput = subjectScope[e:length+1]
                    return self.subjectInput
        
        # if there is no nominal group with DET found
        i = length
        
        while i >= 0: # must not include in the subject the pronouns
            if subjectScope[i] in pronouns:
                length -= 1
            i -= 1
             
        if length == 0: # if there is left only one word, it is very probably the subject
            self.subjectInput.append(subjectScope[0])
            return self.subjectInput
        
        return self.subjectInput
            


    def defaultOutput(self):
        """
        continue the conversation (if Eliza didn't understand the phrase)
        :returns: a random phrase
        """
        return random.choice(self.talkToMeMore)

    def getFinalAnswer(self): 
        """
        process the input entry, compose an answer and return it
        :returns: the answer of Eliza
        """
        
        question = ["C'est votre opinion qui m'intéresse.", "C'est moi qui pose les questions.", "Parlez-moi de vous plutôt."]
        
        rudeWords = ["chier","chie","chié","chiez","chiant","merde","sous-merde","emmerde","emmerdeur",
        "emmerdeuse","emmerdez","emmerder","conasse","connasse","conne","pétasse","poufiasse","grogniasse",
        "grognasse","abrutie","fiotte","connard","abruti","salopard","tasspe","sale porc","batard",
        "pute","putain", "salope","salop","salaud","pestifféré","con","couille", "bite", "cul", 
        "pédé","pd","tafiole","tapette","pédale","bordel","raclure","foutre","nique","niquer"]
        
        answers = ["Ne soyez pas grossier, s'il vous plait!", "Recentrez-vous sur votre objectif !",
        "Veillez à soigner votre langage !", "Vous semblez ne pas avoir compris le but de cette thérapie !",
        "Insulter ceux qui veulent vous aider ne vous mènera à rien !"]
        
        if self.input[:-1] == "?": # if the user entry is a question
            self.output = random.choice(question)
            return self.output
        
        
        self.tokenize(self.input)
        
        testP = self.tokenInput
        for e in testP:  
            if e in rudeWords: # if the user uses rude words
                self.output = random.choice(answers)
                return self.output
                
        
        #this part deals with specific keywords and makes Eliza reply in a different way if they are encountered
        
        badKeywords = ['mort.{0,2}$', 'décédé.{0,2}$', 'défunt.{0,2}$', 'suicidé', 'malades?$', 'malheureux',
        'malheureuse']
            
        for e in testP:
            for i in badKeywords:
                if re.match(e, i):
                    if self.negation(testP) == True:
                        self.output = "C'est bien, il faut continuer à positiver!"
                        return self.output
                    else:
                        lst = ["Je suis désolée d\'apprendre ceci, parler vous fera du bien, continuez. ",
                        "Comme cela est triste... racontez-moi, ceci vous aidera.", "Quelle triste nouvelle... et que ceci vous fait-il ressentir ?"]
                        self.output = random.choice(lst)
                        return self.output 

        goodKeywords = ['heureux', 'heureuse', 'content.{0,2}$', 'joyeux', 'joyeuse', 'joie', 'bonheur',
        'bonne santé']
        for e in testP:
            for i in goodKeywords:
                if re.match(e, i):
                    if self.negation(testP) == True:
                        self.output = "Pourquoi, d'après-vous ? Il faudrait y réfléchir!"
                        return self.output
                    else:
                        lst = ["C\'est une bonne nouvelle ! Dites-m'en plus!", "C'est une très bonne chose, contiuez !"]
                        self.output = random.choice(lst)
                        return self.output 

            
        self.neg = self.negation(self.tokenInput)
        self.tagging()
        self.setPhrase()
        
        return self.output
            

    def switchMe(self, p, dic):
        """
        looks for a key p in the dictionary dic and returns its value
        :param p: a key (string)
        :param dic: a dictionary 
        :returns: if the key p is in the dictionary, returns the corresponding value, if not, returns the key p itself 
        """
      
        if p in dic:
            return dic[p]
        else:
            return p

    
    def split_lefff (self):
        
        """
        reads the LEFFF from text file
        :returns: a list of 4-tuples that represent lines of LEFFF
        """
    
        f = open(self.file_lefff, 'r')
        texte = f.readline()
        lefff = []
    
        while texte != "":
            texte.strip
            sl = texte.split("\t")
            if len(sl) == 4: 
                i = (sl[0], sl[1], sl[2], sl[3]) # tuple : 0-Conjugated form, 1-v, 2-Infinitive, 3-Flexion code
                lefff.append(i)
            texte = f.readline()
        return lefff
    
    
    def recup_inf (self, lefff, verbe, subjectScope):

        """
        finds the infinitive form and the flexion code for a verb form
        :param lefff: splitted LEFFF (list of 4-tuples)
        :param verbe: the verb form to be analysed (String)
        :param subjectScope: the part of the phrase that precedes the verb (token list)
        :returns: tuple (infinitive + flexion) for that verb form
        """
        # dichotomic search does not work when we need to compare strings with diacritic characters (for example, ê). So we had to use brute-force search.
        pos = 0
        while pos < len(lefff): 
                verbform = lefff[pos]
                if verbe == verbform[0]:
                    return (verbform[2], self.prepare_flexion(verbform[3], subjectScope))
                pos += 1
        return 0
        


    
    def flexion (self, f):
        
        """ 
        changes the flexion of the verb to the opposite person, if possible
        :param f: a tuple (infinitif + flexion) 
        :returns: the flexion of the verb in the output of Eliza
        """

        if f[1] in ["Ps1\n", "PSs1\n"]:
            return "Pp2\n"
        if f[1] == "Fs1\n":
            return "Fp2\n"
        if f[1] == "Is2\n":
            return "Ip2\n"
        if f[1] == "Js2\n":
            return "Jp2\n"
        if f[1] == "Ss1\n":
            return "Sp1\n"
        if f[1] == "Ts1\n":
            return "Tp1\n"
        if f[1] == "PSp3\n":
            return "PSp3\n"
        if f[1] == "PSp1\n":
            return "PSp2\n"
        if f[1] == "Cs12\n":
            return "Cp2\n"
        if f[1] == "Is12\n":
            return "Ip2\n"
        if f[1] == "PSs13\n":
            return "PSs13\n"
        if f[1] == "Ps13\n":
            return "Ps13\n"
        if f[1] == "YPs1\n":
            return "Pp2\n"
        if f[1] == "YPp1\n":
            return "YPp2\n"
        return f[1]


    def conjugaison (self, verbtuple, subjectScope):

        """ 
        composes a verb form by its infinitive and its flexion
        :param verbtuple: tuple (infinitif + flexion) for the verb in the output
        :param subjectScope: the part of the phrase that precedes the verb (token list)
        :returns: the conjugated verb form
        """
        
        flexion = self.flexion(verbtuple)
        if flexion != verbtuple[1]: # if the form of the verb does not change, there is no need to search in LEFFF
            lefff = self.split_lefff()
            pos = 0
            while pos < len(lefff): # cannot use dichotomic search here, because two elements are compared
                verbform = lefff[pos]
                if verbform[2] == verbtuple[0] and self.prepare_flexion(verbform[3],subjectScope) == flexion:
                    self.verb = verbform[0]
                    return self.verb
                pos += 1
        
        return self.verb

    
    def stackRead(self):
        """
        reads an element from the stack
        :returns: the last element put in the stack
        """
        
        return self.stack.pop()
    
    
    def stackWrite(self, s): 
        """
        puts an element in the stack
        :param s: the element to be put on top of the stack
        """
        
        self.stack.push(s)
        
    
    def setPhrase(self): 
        """
        builds an output phrase from pieces
        :returns: the output phrase (the phrase to be shown to the user)
        """
        
        determinants = ['un', 'une', 'la', 'le', 'les', 'l\'', 'des', 'ma', 'ta', 'sa', 'mon', 'ton', 'son', 'mes', 'tes', 'ses', 'nos', 'vos', 'leur', 'leurs', 'notre', 'votre']
        
        objectOutput = ""
        for e in range(len(self.objectInput)): # to obtain the object of the output phrase, we transform all the pronouns in the object of the input phrase
            self.objectInput[e] = self.switchMe(self.objectInput[e], self.myPronouns)
            objectOutput += self.objectInput[e]
            objectOutput += " "
        objectOutput.strip()
        
        # if Eliza did not understand the verb AND the subject of the input
        
        if self.verb == "" and len(self.subjectInput) == 0: 
            for i in range(len(self.objectInput)): # search for keywords in the object
                word = self.objectInput[i]
                for key in allMyKeywords.keys():
                    if re.match(key, word):
                        if allMyKeywords[word] == 'human':
                            wordOutput = "cette personne"
                            if i > 0 and self.objectInput[i-1] in determinants:
                                det = self.switchMe(self.objectInput[i-1])
                                wordOutput = det
                                wordOutput += " "
                                wordOutput += word
                            
                            phrase1 = "Je vois, et que représente " + wordOutput + " pour vous?"
                            phrase2 = "Passez-vous beaucoup de temps avec " + wordOutput + "?"
                            phrase3 = "Et que pense " + wordOutput + " de ceci?"
                            phrase4 = "Vous en avez parlé avec " + wordOutput + "?"
                            phrase5 = "Parlez-moi encore de " + wordOutput + "."
                            phrase6 = "Parlez-moi de vos relations avec " + wordOutput + "."
                            self.output = random.choice([phrase1, phrase2, phrase3, phrase4, phrase5, phrase6])
                            
                            return self.output
                        
                        else:
                            wordOutput = "cela"
                            if i > 0 and self.objectInput[i-1] in determinants:
                                det = self.switchMe(self.objectInput[i-1])
                                wordOutput = det
                                wordOutput += " "
                                wordOutput += word
                                
                            phrase1 = "Je vois, et que représente " + wordOutput + " pour vous?"
                            phrase2 = "Parlez-moi plus de " + wordOutput + "."
                            phrase3 = "Est-ce que " + wordOutput + ", c'est important pour vous?"
                            phrase4 = "Quel rôle joue " + wordOutput + " dans votre vie?"
                            self.output = random.choice([phrase1, phrase2, phrase3, phrase4])
                            
                            return self.output
                        
            if self.stack.size() > 0: # if there are no keywords in the phrase, search for topics in the stack
                memory = ""
                tuple_memory = self.stackRead()
                memory = tuple_memory[0] + " " + tuple_memory[1]
                phrase1 = "Revenons a " + memory + ". Pourriez-vous m'en parlez plus?"
                phrase2 = "Parlez-moi plus de " + memory + ", s'il vous plait."
                phrase3 = "Parlez-moi encore de " + memory + ", c'est important pour vous?"
                self.output = random.choice([phrase1, phrase2, phrase3])
            
                return self.output
            else: # if the stack is empty, Eliza gives a random answer
                self.output = self.defaultOutput()
                
                return self.output
        
        # if Eliza understood the subject, but not the verb
        elif self.verb == "" and len(self.subjectInput) > 0: 
            subjectOutput = ""
            if len(self.subjectInput) > 1: #determinant + noun + extensions
                for i in range(len(self.subjectInput)): #to obtain the subject of the output, we change the pronouns in the subject of the input
                    self.subjectInput[i] = self.switchMe(self.subjectInput[i], self.myPronouns)
                    subjectOutput += self.subjectInput[i]
                    subjectOutput += " "
                subjectOutput.strip()
            else: # if the subject is a single word
                if self.subjectInput[0] in ["tu", "t'", "vous"]:
                    self.output = random.choice(["Vous êtes là pour parler de vous, pas de moi.", "On ne parle pas de moi ici.", "On est ici pour parler de vous."])
                    return self.output
                elif self.subjectInput[0] in ["je", "j'", "nous"]:
                    self.output = random.choice(["Parlez-moi plus de vous, s'il vous plait.", "C'est important, continuez.", "Parlez-moi davantage sur votre vie.", "Parlez-moi de vos relations avec les autres."])
                    return self.output
                else:
                    subjectOutput = self.switchMe(self.subjectInput[0], self.myPronouns)
            
            if subjectOutput == "": # impossible
                self.output = self.defaultOutput()
                return self.output
                
            
            phrase1 = "Je vois, et que représente " + subjectOutput + " pour vous?"
            phrase2 = "Parlez-moi plus de " + subjectOutput + "."
            phrase3 = "Est-ce que " + subjectOutput + ", c'est important pour vous?"
            phrase4 = "Quel rôle joue " + subjectOutput + "dans votre vie?"
            phrase5 = "Parlez-moi encore de " + subjectOutput + "."
            
            self.output = random.choice([phrase1, phrase2, phrase3, phrase4, phrase5])
            
            return self.output
        
        # if Eliza understood the subject AND the verb
        elif len(self.subjectInput) > 0 and self.verb != "": 
            
            verbOutput = self.verb
            if len(self.verbtuple) > 0:
                verbOutput = self.conjugaison(self.verbtuple, self.subjectInput) # switch the verb
            
            
            subjectOutput = ""
            if len(self.subjectInput) > 1: 
                for i in range(len(self.subjectInput)):
                    self.subjectInput[i] = self.switchMe(self.subjectInput[i], self.myPronouns)
                    subjectOutput += self.subjectInput[i]
                    subjectOutput += " "
                subjectOutput.strip()
            else:
                if self.subjectInput[0] in ["tu", "t'", "vous"]:
                    self.output = random.choice(["Vous êtes là pour parler de vous, pas de moi.", "On ne parle pas de moi ici.", "On est ici pour parler de vous."])
                    return self.output
                else:
                    subjectOutput = self.switchMe(self.subjectInput[0], self.myPronouns)
            
            if subjectOutput == "": # impossible
                self.output = self.defaultOutput()
                return self.output
            
                
            if self.neg:
                variability = ['Pourquoi ne', 'Mais d\'après vous, pourquoi ne', 'Je vois, mais selon vous, pourquoi ne', 
                'Mais selon vous, pourquoi ne', 'Et d\'après vous, pourquoi ne', 'D\'accord, mais pourquoi ne', 'Et pourquoi ne',
                'Je vois, et selon vous, pourquoi ne', 'Très bien, mais pourquoi ne', 'Et selon vous, pourquoi ne', 
                'Et en quoi ne', 'Selon vous, en quoi ne', 'D\'après vous, en quoi ne']
                if subjectOutput in ['vous', 'ils', 'elles']:
                    self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif subjectOutput in ['il', 'elle']:
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['la', 'une', 'cette']:
                    subjectOutput = "elle"
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['le', 'un', 'cet', 'ce']:
                    subjectOutput = "il"
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['les', 'ces']: #pas de "des" car ambigu: article pl ou prep+article
                    subjectOutput = "ils"
                    self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                    
                else:
                    phrase1 = "Pourquoi dites-vous que " + subjectOutput + " ne " + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase2 = "Pourquoi pensez-vous que " + subjectOutput + " ne " + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase3 = "Qu'est ce que vous fait dire que " + subjectOutput + " ne " + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase4 = "Je vois, " + subjectOutput + " ne " + self.refl_pro + " " + verbOutput + " " + objectOutput + ". Continuez, s'il vous plait."
                
                    self.output = random.choice([phrase1, phrase2, phrase3, phrase4])
            else:
                variability = ['Pourquoi ', 'Mais d\'après vous, pourquoi ', 'Je vois, mais selon vous, pourquoi ', 
                'Mais selon vous, pourquoi ', 'Et d\'après vous, pourquoi ', 'D\'accord, mais pourquoi ', 'Et pourquoi ',
                'Et en quoi ', 'Je vois, et selon vous, pourquoi ', 'Très bien, mais pourquoi ', 'Et selon vous, pourquoi ' 
                'Et en quoi ', 'Selon vous, en quoi ', 'D\'après vous, en quoi']
                if subjectOutput in ['vous', 'ils', 'elles']:
                    self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif subjectOutput in ['il', 'elle']:
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['la', 'une', 'cette']:
                    subjectOutput = "elle"
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['le', 'un', 'cet', 'ce']:
                    subjectOutput = "il"
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['les', 'ces']: #pas de "des" car ambigu: article pl ou prep+article
                    subjectOutput = "ils"
                    self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                
                else:
                    phrase1 = "Pourquoi dites-vous que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase2 = "Pourquoi pensez-vous que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase3 = "Qu'est ce que vous fait dire que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase4 = "Je vois, " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + ". Continuez, s'il vous plait."
                    
                    self.output = random.choice([phrase1, phrase2, phrase3, phrase4])
                        
                
        
        if self.output == "": # impossible
            self.output = self.defaultOutput()
            
        return self.output
                
    
    def res_fields(self):
        """
        reset all fields to 0
        """
        self.input = ""
        self.tokenInput = []
        self.subjectInput = []
        self.objectInput = []
        self.verb = ""
        self.neg = False
        self.output = ""
        self.refl_pro = ""     
    
    
    def prepare_flexion(self, flexion, subjectScope):
        """
        prepare flexions in LEFFF for the flexion(f) function (desambiguation of LEFFF flexion codes)
        :param flexion: the flexion code in LEFFF
        :param subjectScope: the part of the phrase that precedes the verb (token list)
        :returns: the desambiguated flexion code
        """
        if flexion[0] == 'Y': # this verb form can be an imperative - we don't need this information
            flexion = flexion[1:]
        for i in range(len(flexion)):
            if flexion[i] == '1': 
                if i+1 < len(flexion):
                    if flexion[i+1] in ['2','3']: # this form can correspond to 1st and 2nd person or to 1st and 3rd person
                        for e in subjectScope:
                            if e in ['je', 'j\'']: # it is 1st person - we delete the second number
                                new_flexion = flexion[:i+1]
                                if i+2 < len(flexion):
                                    new_flexion += flexion[i+2:]
                                return new_flexion
                    
                        # if it is not 1st person, we delete '1'
                        if i>0:
                            new_flexion = flexion[:i]
                        else:
                            new_flexion = []
                        
                        new_flexion += flexion[i+1:]
                        return new_flexion
        return flexion
                    
                    
    
talkToMeMore = ["Pourriez-vous m'en dire plus?", "Que voulez-vous dire?", "Pourriez-vous élaborer?", "Pourriez-vous développer sur ce sujet?",
        "Que voulez-vous dire par là?", "Pourriez-vous m'en dire d'avantage?", "Qu'est-ce que cela veut dire pour vous?", "Ceci a-t-il un sens particulier pour vous?",
        "Et que ceci vous inspire-t-il?"]

allMyKeywords={'propriétaires?': 'human', 'familles?': 'human', 'fils': 'human', 'électricien.{0,3}': 'human', 'épou.{1,2}': 'human',
'patron.{0,3}$': 'human', 'voisin.{0,2}$': 'human', 'frères?': 'human', 'soeurs?': 'human',
'comptables?': 'human','copains?': 'human', 'femmes?': 'human', 'fromagers?': 'human',
'belles?-filles?': 'human', 'maris?': 'human', 'diéticien.{0,3}': 'human', 'grands?-mères?': 'human',
'beaux?-frères?': 'human', 'oncles?': 'human', 'belles?-mères?': 'human', 'potes?': 'human',
'cousin.{0,2}': 'human', 'ami.{0,2}$': 'human', 'élèves?': 'human', 'petits?-fils': 'human',
'pédiatres?': 'human', 'femme de ménage': 'human', 'psychologues?': 'human', 'médecins?': 'human',
'beaux?-fils': 'human', 'petites?-fille': 'human', 'plombiers?': 'human', 'collègues?': 'human',
'architectes?': 'human', 'tantes?': 'human', 'boucher': 'human', 'père': 'human', 'psychiatres?': 'human',
'belles?-soeurs?': 'human', 'petite?-amie?': 'human', 'copines?': 'human', 'beaux?-pères?': 'human',
'grands?-pères?': 'human', 'filles?': 'human', 'boulanger': 'human', 'docteurs?': 'human', 'mère': 'human',
'profs?$': 'human', 'professeurs?': 'human', 'professions?':'obj', 'chats?$': 'animal', 'chiens?': 'animal', 'poissons?$': 'animal', #'poissons? rouges?': 'animal',
'voitures?': 'obj', 'maisons?': 'obj', 'travail$': 'obj', 'jobs?': 'obj','métiers?': 'obj', 'enfants?': 'human', 'ordinateurs?':'obj',
'bureaux?': 'obj'}

psychoVerbs = {'haïr': 'Hate', 'aimer': 'Love',  'détester': 'Hate', 'adorer': 'Love',
'terroriser': 'NegFear', 'effrayer': 'NegFear' , 'alarmer': 'NegFear', 'terrifier': 'NegFear',
'paniquer': 'NegFear', 'intimider': 'NegFear', 'peiner': 'NegSad', 'attrister': 'NegSad',  
'inquiéter': 'NegFear', 'épouvanter': 'NegFear', 'angoisser': 'NegFear', 'abhorrer': 'Hate', 
'mépriser': 'Hate', 'dénigrer': 'Hate', 'paniquer': 'NegFear', 'jouir': 'Love', 'apprécier': 'Love', 
'stresser': 'NegFear', 'plaire': 'Love'}

myPronouns = {'je':'vous', 'j\'':'vous', 'me':'vous', 'm\'':'vous', 'moi':'vous', 'tu':'je', 'te':'me', 't\'':'me',
'toi':'moi', 'nous':'vous', 'mien':'vôtre','tien':'mien', 'sien':'sien','mienne':'vôtre', 'tienne':'mienne',
'sienne':'sienne', 'miens':'vôtres', 'tiens':'miens','siens':'siens','miennes':'vôtres', 'tiennes':'miennes',
'siennes':'siennes','nôtre':'vôtre','vôtre':'mien', 'leur':'leur','nôtre':'vôtre', 'vôtre':'mienne','leur':'leur',
'nôtres':'vôtres','vôtres':'miennes', 'leurs':'leurs', 'ma':'votre', 'ta':'ma', 'mon':'votre', 'ton':'mon', 'mes':'vos', 
'notre':'votre', 'tes':'mes', 'votre':'mon', 'nos':'vos', 'vos':'mes'}

reflexive = {'me' : 'vous', 'm\'' : 'vous', 'se' : 'se', 's\'' : 's\'', 'nous' : 'vous', 'te' : 'me', 't\'' : 'm\'', 'vous' : 'me'}


detPoss = det = {'ma':['votre'], 'mon':['votre'], 'un':['cet'], 'une':['cette'], 'des':['ces'], 'nos':['vos'], 'notre':['votre']}


