#!/bin/env python
# -*- coding: utf-8 -*-

import time
import random
import Tkinter
import re
import stack


"""
Created on Tue Apr 23 10:36:29 2013

@author: BAbemonty, MChassang, KKiranova, JTanon
"""
class eliza(): 

    def __init__(self):
        
        """
        @param String self.input                -   user entry from GUI
        @param str-List self.tokenInput         -   token list from user input   
        @param str-List self.subjectInput       -   token list for subject scope
        @param str-List self.objectInput        -   token list for object scope
        @param String self.verb                 -   identified verb
        @param str-Tuple self.verbtuple         -   tuple infinitif + flexion
        @param tuple-List self.stack            -   stack of keywords and objects (Eliza's memory)
        @param String self.output               -   calculated answer (to be sent back to GUI)  
        @param String-dict self.myPronouns      -   pronouns dictionary
        @param String-dict self.talkToMeMore    -   random sentence (if self.output is empty)
        @param String-dict self.psychoVerbs     -   psychological verbs dictionary
        @param String-dict self.allMyKeywords   -   keywords dictionary

        """
        
        self.input = "" 
        self.tokenInput = [] 
        self.subjectInput = []  
        self.objectInput = []  
        self.verb = ""  
        self.verbtuple = [] 
        self.stack = stack.stack()
        self.output = "" 
        self.refl_pro = "" #pronom reflechi eventuellement #AJOUTE 19/06 Kira
        self.myPronouns = myPronouns
        self.talkToMeMore = talkToMeMore
        self.psychoVerbs = psychoVerbs
        self.reflexive = reflexive
        self.allMyKeywords = allMyKeywords
    
    
    def setInput(self, text):
        """
        @param String text  -   user entry
        """
        
        self.input = text.encode('utf-8').lower() #lower, sauf si on decide de mettre un truc genre "ne criez pas!"
        #self.input # NEW tuesday 18
        


    def tokenize (self, entry):
        """
        @param String entry     -   user entry
        """
        
        s = entry
        token_list = []
        f = 1 # end of the token
        d = 0 # first symbol of the token
        elision = ['c', 'd', 'j', 'l', 'm', 'n', 's', 't'] # short words elided before an apostrophe, like me - m', ce - c'
        ponct = ['.', ',', '!', '?', ';', ':', '"', '(', ')', '[', ']']
        while f < len(s):
            word = ""
            sponct = "" 
            if(s[f] == " "):
                word = s[d:f]
                f += 1
                d = f
            elif(s[f] in ponct):
                sponct = s[f]
                word = s[d:f]
                if(f+1 < len(s)and s[f+1] == " "):
                    f += 2
                else:
                    f += 1
                d = f
            elif(s[f] == "'"): # if there's an apostrophe, it can be one word or two
                if(s[f-1].lower() in elision):
                    if(f-1 == 0): # first symbol of the phrase : it is an elided word
                        word = s[d:f+1]
                        f += 1
                        d = f
                    elif(s[f-2] ==" "): # first symbol of the word : it is an elided word
                        word = s[d:f+1]
                        f += 1
                        d = f
                    else: # it is a word with an apostrophe in the middle (like "aujourd'hui")
                        f += 1
                else: # not a lettre from the elision list : it can't be two words
                    f += 1
            else:
                f += 1
            
            if(word != ""):
                token_list.append(word)
            if(sponct != ""):
                token_list.append(sponct)
                
        if(d != len(s)): # if the last word is not in the token list, add it
            word = s[d:]
            token_list.append(word)
        
        if token_list[-1] in ponct:
            token_list = token_list[:-1] # on ne garde pas le point a la fin 
        
        self.tokenInput = token_list
    
    #NEW - ADDED WED 19
    def negation (self, t):
        lst1 = ["jamais", "rien", "ne", "n\'", "ni"]
        
        lst3 = ["pas", "plus", "point"]
        
        for e in t:
            if e in lst1 :
                return True
            elif e in lst3:
                for elem  in lst1:
                    if elem in t:
                        return True
    
        return False
    
    def tagging(self): #ma version de tagging - Kira

        print "testtagg"
        lst = self.tokenInput
        #print lst
        # recherche de verbe
        posVerb = len(lst)-1
        
        #pronouns = ['c\'', 'j\'', 'm\'', 'n\'', 's\'', 't\'', 'me', 'te', 'se', 'ne'] #precedent toujours un verbe
        for elem in range(len(lst)):
            for i in self.allMyKeywords:
                if re.match(i, lst[elem]): #recherche avec regex
                    self.stackWrite(lst[elem]) #stakWrite prend un argu?? oui c'est push!

        if self.verb == "":
            lefff = self.split_lefff()
            for e in range(len(lst)):
                if lst[e] != 'tu': #sinon elle pense que tu est le participe passe de taire!
                    in_lefff = self.recup_inf(lefff, lst[e], lst[:e])
                    if in_lefff != 0: # si verbe trouve dans Lefff
                        self.verb = lst[e]
                        print "test"
                        print len(self.verb)
                        self.verbtuple = in_lefff #infinitif+flexion
                        print self.verb
                        print self.verbtuple
                        posVerb = e
                        subjectScope =  lst[:posVerb]
                        if self.verbtuple[0] in self.psychoVerbs:
                            if self.negation(self.tokenInput) == True: 
                                if self.psychoVerbs[self.verbtuple[0]] == 'NegFear':
                                    if self.tuple[0] in ['paniquer', 'angoisser', 'stresser']:  
                                        lst = ["Faire preuve de self-contrôle est une bonne chose! Continuez, je voudrais en savoir plus sur ce sujet.", 
                                        "Prendre les choses calmement, voilà une bonne approche! Dites m'en plus.", 
                                        "Savoir prendre les choses du bon côté est une vertu. Dites m'en plus!"]
                                    else:
                                        lst = ["C'est plutôt une bonne chose, non?", "Etes-vous d'acord pour dire que c'est une bonne chose?"
                                        "Pensez-vous que ce soit une mauvaise chose ?"]
                                    self.output = random.choice(lst)
                                    return self.output

                                elif self.psychoVerbs[self.verbtuple[0]] == 'NegSad':
                                    lst = ["C'est plutôt une bonne chose, ne pensez-vous pas ?", "C'est bien! Dites-m'en plus!"]
                                    self.output = random.choice(lst)
                                    return self.output
                                
                                elif self.psychoVerbs[self.verbtuple[0]] == 'Love':
                                    lst = ["C'est un peu triste, pourquoi donc ?", "Pourriez-vous me dire pourquoi ?", 
                                    "Pensez-vous que ceci est lié à une mauvaise expérience passée ?"]
                                    self.output = random.choice(lst)
                                    return self.output

                                else:
                                    lst = ["Je vois. Ce n'est pas non plus le grand amour cependant, pourriez-vous me dire pourquoi  ?",
                                    "D'accord, le sentiment n'est pas complètement négatif. Pourquoi pas simplement positif ? ", 
                                    "C'est mieux que rien! N'êtes-vous pas d'accord ?"]
                                    self.output = random.choice(lst)
                                    return self.output

                            else:             
                                if self.psychoVerbs[self.verbtuple[0]] == 'NegFear':
                                    if self.tuple[0] in ['paniquer', 'angoisser', 'stresser']:  
                                        lst = ["Decrivez-moi précisement vos sentiments à ce sujet, que ressentez-vous vraiment ?", 
                                        "Pourquoi vous sentez-vous mal par rapport à cela ?", "Qu'est-ce que cela fait ressurgir chez vous ?"]
                                    else:
                                        lst = ["Pourquoi faire cela ? Qu'est-ce que ça vous apporte ?", "Pourquoi faire cela ? Est-ce que ça vous amuse ?",
                                        "J'aimerais comprendre vos motivations, pourquoi agir ainsi ?"]
                                    self.output = random.choice(lst)
                                    return self.output

                                elif self.psychoVerbs[self.verbtuple[0]] == 'NegSad':
                                    lst = ["Je suis desolée d'apprendre cela, continuez, parler vous aidera.",
                                    "Je comprends... Dans ce cas, ne gardez pas ça pour vous, racontez-moi l'histoire."
                                    "Continuez, garder ceci pour vous ne vous aidera pas, je suis là pour vous aider."]
                                    self.output = random.choice(lst)
                                    return self.output
                                
                                elif self.psychoVerbs[self.verbtuple[0]] == 'Love':
                                    lst = ["C'est un sentiment plutôt positif! Continuez!", "Je comprends, c'est un bon sentiment! Dites m'en plus!",
                                    "Très bien, ne vous arrêtez pas en si bon chemin, c'est une idée positive!"]
                                    self.output = random.choice(lst)
                                    return self.output

                                else:
                                    lst = ["Pourquoi un sentiment aussi négatif ?", "J'aimerais comprendre l'origine de ce sentiment négatif, cotinuez s'il vous plait.",
                                    "Comment se fait-il que vous ayez une opinion si négative ?", "Expliquez-moi ce qui ne va pas."]
                                    self.output = random.choice(lst)
                                    return self.output
                        else:
                            
                            posVerb = e

                            if e > 1: #s'il y a au moins 2 mots avant le verbe alors il peut y avoir un pronom reflechi
                                if lst[e-1] in self.reflexive.keys():
                                    if lst[e-1] == 'nous':
                                        for i in range(0,e-1):
                                            if lst[i] == 'nous':
                                                self.refl_pro = 'vous'
                                    elif lst[e-1] == 'vous':
                                        for i in range(0,e-1):
                                            if lst[i] == 'vous':
                                                self.refl_pro = 'nous'
                                    else:
                                        self.refl_pro = self.reflexive[lst[e-1]]
                            break

        #recherche de sujet
        subjectScope = lst[:posVerb]
        ponct = ['.', ',', '!', '?', ';', ':']
        newScope = subjectScope
        
        for i in range(len(subjectScope)):
            if subjectScope[i] in ponct:
                if i+1 < len(subjectScope):
                    newScope = subjectScope[i+1:]
                else:
                    newScope = []
        
        subjectScope = newScope
                
        
        #print subjectScope
        if len(subjectScope) > 0:
            self.searchSubject(subjectScope)
        
        
        #recherche d'objet
        idx = posVerb + 1
        if idx != len(lst):
            self.objectInput = lst[idx:]                   
        
        
           
    
    def searchSubject(self, subjectScope):
        lstPro = ['je$', 'tu$', 'ils?$', 'j\'$', 'elles?$', 'on$'] # les $ apres chaque mot servent a marquer que c'est la fin du mot. Sinon on trouve "lesssss" pour les?, "lac" pour la, "savoir" pour sa etc.
        for e in subjectScope:
            for pro in lstPro:
                if re.match(pro, e):
                    self.subjectInput.append(e)
                    return self.subjectInput
        return self.searchDet(subjectScope)

    
    def searchDet(self, subjectScope):
        length = len(subjectScope)-1
        elem = subjectScope[length] #- !! ALWAYS OUT OF RANGE !! reglé - on n'appelle pas la fonction si subjectScope est vide - Kira
        pronouns = ['c\'', 'l\'', 'm\'', 'n\'', 's\'', 't\'', 'me', 'te', 'se', 'ne', 'la', 'le', 'les']
        lstDet = ['les?$', 'la$', 'une?$', 'des$', 'l\'$', 'mon$', 'ton$',
        'son$', 'ma$', 'ta$', 'sa$', 'mes$', 'tes$', 'ses$', 'nos$', 'vos$', 'leurs?$',
        'notre$', 'votre$', 'ce.{0,3}$', 'deux$', 'trois$', 'quatre$', 'cinq$', 'aucun.*',
        'tel.*', 'quelques?$', 'certain.*', 'divers.*', 'tou.{1,3}$']

        for e in range(len(subjectScope)):
            for det in lstDet:
                if re.match(det, subjectScope[e]):
                    if elem in pronouns:
                        self.subjectInput = subjectScope[e:length]
                    else:
                        self.subjectInput = subjectScope[e:length+1]
                    return self.subjectInput
        return self.subjectInput



    def defaultOutput(self):
        return random.choice(self.talkToMeMore)

    def getFinalAnswer(self): #reponse finale d'eliza
       
        # ma version - Kira - Super - reste plus qu'à gérer les cas ou y'a un mot vulgaire ou un verbe psycho, mais ça sera sûrement ailleurs, on voit ça mercredi!
        f = self.input
        x = ["C'est votre opinion qui m'intéresse.", "C'est moi qui pose les questions.", "Parlez-moi de vous plutôt."]
        rudeWords = ["chier","chie","chié","chiez","chiant","merde","sous-merde","emmerde","emmerdeur",
        "emmerdeuse","emmerdez","emmerder","conasse","connasse","conne","pétasse","poufiasse","grogniasse",
        "grognasse","abrutie","fiotte","connard","abruti","salopard","tasspe","sale porc","batard",
        "pute","putain", "salope","salop","salaud","pestifféré","con","couille", "bite", "cul", 
        "pédé","pd","tafiole","tapette","pédale","bordel","raclure","foutre","nique","niquer"]
        
        answers = ["Ne soyez pas grossier, s'il vous plait!", "Recentrez-vous sur votre objectif !",
        "Veillez à soigner votre langage !", "Vous semblez ne pas avoir compris le but de cette thérapie !",
        "Insulter ceux qui veulent vous aider ne vous mènera à rien !"]
        if f[:-1] == "?": #Si jamais l'input c'est une question
            self.output = random.choice(x)
            return self.output
        self.tokenize(self.input)
        testP = self.tokenInput
        for e in testP: #Si jamais input vulgaire - 
            if e in rudeWords:
                self.output = random.choice(answers)
                return self.output
        
        self.tagging()
        self.setPhrase()
    
        return self.output
        

    #def returnFinal(self, sentence):


    #LEFFF
    def split_lefff (self):
    
        f = open("Lefff.txt", 'r') #Ouverture du fichier (lecture)
        texte = f.readline()
        lefff = []
    
        while texte != "":
            texte.strip
            sl = texte.split("\t")
            if len(sl) == 4: #sinon donne index out of range - Kira
                i = (sl[0], sl[1], sl[2], sl[3]) #Tuple :  0-Forme conjuguée, 1-v, 2-Infinitif, 3-Code flexion
                lefff.append(i)
            texte = f.readline()
        return lefff  
        
    
    def recup_inf (self, lefff, verbe, subjectScope):

        """Fonction qui recupere l'infinitif et la flexion du verbe en input
        @param lefff le lefff 'splitted' (e-List)
        @param verbe le verbe de l'input (e)
        @param subjectScope la partie de la phrase dans laquelle se trouve le sujet du verbe
        @return tuple infinitif+flexion (e-Tuple)
        """
        
        pos = 0
        while pos < len(lefff): #ici, on ne peut pas utiliser la recherche dichotomique a cause des verbes irreguliers (suis - etre : loin dans l'alphabet)
                verbform = lefff[pos]
                if verbe == verbform[0]:
                    return (verbform[2], self.prepare_flexion(verbform[3], subjectScope))
                pos += 1
        return 0
        
        #return self.recup_inf_rec(lefff, verbe, 0, len(lefff), subjectScope)
        
        
    def recup_inf_rec(self, lefff, verbe, debut, fin, subjectScope): #fonction recursive
        # recherche dichotomique
        
        while debut < fin:

            m = (debut+fin)/2;
            val = lefff[m]
            
            if(val[0] == verbe):
                return (val[2], val[3])
            elif(val[0] > verbe):
                return self.recup_inf_rec(lefff, verbe, debut, m, subjectScope)
            else:
                return self.recup_inf_rec(lefff, verbe, m+1, fin, subjectScope)
            
        return 0
        
    
    
    def flexion (self, f):
        
        """ Fonction qui determine la flexion de l'output
        @param f tuple infinitif+flexion (e-Tuple)
        @return f[1] la flexion de l'output (e)
        @return la flexion de l'output (e)"""

        if f[1] in ["Ps1\n", "PSs1\n"]:
            return "Pp2\n" #Pp2 et pas P2p - Kira
        if f[1] == "Fs1\n":
            return "Fp2\n"
        if f[1] == "PSs3\n":
            return "PSs3\n"
        if f[1] == "Is2\n":
            return "Ip2\n"
        if f[1] == "Js2\n":
            return "Jp2\n"
        if f[1] == "Ss1\n":
            return "Sp1\n"
        if f[1] == "Ts1\n":
            return "Tp1\n"
        if f[1] == "PSp3\n": 
            return "PSp3\n"
        if f[1] == "PSp1\n":
            return "PSp2\n"
        if f[1] == "Cs12\n":
            return "Cp2\n"
        if f[1] == "Is12\n":
            return "Ip2\n"
        if f[1] == "PSs13\n":
            return "PSs13\n"
        if f[1] == "Ps13\n":
            return "Ps13\n"
        if f[1] == "YPs1\n":
            return "Pp2\n"
        if f[1] == "YPp1\n":
            return "YPp2\n"
        return f[1]


    def conjugaison (self, verbtuple, subjectScope):

        """ Fonction qui renvoie le verbe conjugue pour l'output
        @param t_inf_flex tuple infinitif+flexion output (e-Tuple)
        @param lefff le lefff "splited" (e-List)
        @param subjectScope la partie de la phrase ou se trouve le sujet du verbe
        @return le verbe conjugue (e)"""
        
        """
        s = self.verb
        f = split_lefff()
        v = recup_inf (f, s)
        t_inf_flex = (v[0], flexion(v))
        pos = 0
        while pos < len(lefff):
            if lefff[pos][2] == t_inf_flex[0] and lefff[pos][3] == t_inf_flex[1]:
                return lefff[pos][0]
            pos = pos + 1
        return talkToMeMore()
        """
        
        #version modifiee - Kira
        print verbtuple
        flexion = self.flexion(verbtuple)
        if flexion != verbtuple[1]: #evite de parcourir le Leff si la forme du verbe ne change pas
            lefff = self.split_lefff()
            pos = 0
            while pos < len(lefff): #ici, on ne peut pas utiliser la recherche dichotomique a cause des verbes irreguliers (suis - etre : loin dans l'alphabet)
                verbform = lefff[pos]
                if verbform[2] == verbtuple[0] and self.prepare_flexion(verbform[3],subjectScope) == flexion:
                    self.verb = verbform[0]
                    return self.verb
                pos += 1
        print self.verb
        return self.verb
        
    

     # nouvelle fonction qui gere des ambiguites dans lefff - Kira
    def prepare_flexion(self, flexion, subjectScope):
        print "testest"
        if flexion[0] == 'Y': #si ca peut etre un imperatif
            flexion = flexion[1:]
        for i in range(len(flexion)):
            if flexion[i] == '1':
                if i+1 < len(flexion):
                    if flexion[i+1] in ['2','3']: # si on a 12 ou 13 dans la flexion
                        for e in subjectScope:
                            if e in ['je', 'j\'']: #c'est la premiere personne
                                new_flexion = flexion[:i+1]
                                if i+2 < len(flexion):
                                    new_flexion += flexion[i+2:]
                                return new_flexion
                    
                        #sinon ce n'est pas la premiere personne
                        if i>0:
                            new_flexion = flexion[:i]
                        else:
                            new_flexion = []
                        
                        new_flexion += flexion[i+1:]
                        return new_flexion
        return flexion
    
    def stackRead(self): #lecture de la pile # MARINE
        return self.stack.pop()
    
    def stackWrite(self, s): #ecriture de la pile # MARINE
        self.stack.push(s)
        
    def setPhrase(self): # fonction qui genere l'output
        #print self.subjectInput
        determinants = ['un', 'une', 'la', 'le', 'les', 'l\'', 'des', 'ma', 'ta', 'sa', 'mon', 'ton', 'son', 'mes', 'tes', 'ses', 'nos', 'vos', 'leur', 'leurs', 'notre', 'votre']
        objectOutput = ""
        for e in range(len(self.objectInput)): #on change je-vous dans l'objet et on le transforme en chaine de caracteres
            self.objectInput[e] = self.switchMe(self.objectInput[e], self.myPronouns)
            objectOutput += self.objectInput[e]
            objectOutput += " "
        objectOutput.strip()
        
        if self.verb == "" and len(self.subjectInput) == 0: # si on a rien, on cherche des mots-cles dans l'objet
            for i in range(len(self.objectInput)):
                word = self.objectInput[i]
                for key in allMyKeywords.keys():
                    if re.match(key, word):
                        if allMyKeywords[word] == 'human':
                            wordOutput = "cette personne"
                            if i > 0 and self.objectInput[i-1] in determinants:
                                det = self.switchMe(self.objectInput[i-1])
                                wordOutput = det
                                wordOutput += " "
                                wordOutput += word
                            
                            phrase1 = "Je vois, et que représente " + wordOutput + " pour vous?"
                            phrase2 = "Passez-vous beaucoup de temps avec " + wordOutput + "?"
                            phrase3 = "Et que pense " + wordOutput + "de ceci?"
                            phrase4 = "Vous en avez parlé avec " + wordOutput + "?"
                            phrase5 = "Parlez-moi encore de " + wordOutput + "."
                            phrase6 = "Parlez-moi de vos relations avec " + wordOutput + "."
                            self.output = random.choice([phrase1, phrase2, phrase3, phrase4, phrase5, phrase6])
                            #res = self.output
                            #self.res_fields() #-AJOUT MON 17
                            #return res #old -
                            return self.output
                        else:
                            wordOutput = "cela"
                            if i > 0 and self.objectInput[i-1] in determinants:
                                det = self.switchMe(self.objectInput[i-1])
                                wordOutput = det
                                wordOutput += " "
                                wordOutput += word
                                
                            phrase1 = "Je vois, et que représente " + wordOutput + " pour vous?"
                            phrase2 = "Parlez-moi plus de " + wordOutput + "."
                            phrase3 = "Est-ce que " + wordOutput + ", c'est important pour vous?"
                            phrase4 = "Quel role joue " + wordOutput + "dans votre vie?"
                            self.output = random.choice([phrase1, phrase2, phrase3, phrase4])
                            #res = self.output #-AJOUT MON 17
                            #self.res_fields() #-AJOUT MON 17
                            #return res #old
                            return self.output
                        
            if self.stack.size() > 0: # sinon on prend de la pile
                memory = self.stackRead() #NEW - ajouter un det ici, non? Comme "votre chat"? oui mais pour ca il faut que le nom dans la pile soit avec son det
                phrase1 = "Revenons a " + memory + ". Pourriez-vous m'en parlez plus?"
                phrase2 = "Parlez-moi plus de " + memory + ", s'il vous plait."
                phrase3 = "Parlez-moi encore de " + memory + ", c'est important pour vous?"
                self.output = random.choice([phrase1, phrase2, phrase3])
                #res = self.output #-AJOUT MON 17
                #self.res_fields() #-AJOUT MON 17
                #return res #old
                return self.output
            else:
                self.output = self.defaultOutput()
                #res = self.output #-AJOUT MON 17
                #self.res_fields() #-AJOUT MON 17
                #return res #old
                return self.output
        
        elif self.verb == "" and len(self.subjectInput) > 0: #si on a le sujet mais pas le verbe
            subjectOutput = ""
            if len(self.subjectInput) > 1: #determinant + nom + eventuellement des adjectifs
                for i in range(len(self.subjectInput)):
                    self.subjectInput[i] = self.switchMe(self.subjectInput[i], self.myPronouns)
                    subjectOutput += self.subjectInput[i]
                    subjectOutput += " "
                subjectOutput.strip()
            else:
                if self.subjectInput[0] in ["tu", "t'", "vous"]:
                    self.output = random.choice(["Vous etes la pour parler de vous, pas de moi.", "On ne parle pas de moi ici.", "On est ici pour parler de vous."])
                    return self.output
                elif self.subjectInput[0] in ["je", "j'", "nous"]:
                    self.output = random.choice(["Parlez-moi plus de vous, s'il vous plait.", "C'est important, continuez.", "Parlez-moi davantage sur votre vie.", "Parlez-moi de vos relations avec les autres."])
                    #res = self.output #-AJOUT MON 17
                    #self.res_fields() #-AJOUT MON 17
                    #return res #old
                    return self.output
                else:
                    subjectOutput = self.switchMe(self.subjectInput[0], self.myPronouns)
            
            if subjectOutput == "":
                self.output = self.defaultOutput()
                return self.output
                
            
            phrase1 = "Je vois, et que représente " + subjectOutput + " pour vous?"
            phrase2 = "Parlez-moi plus de " + subjectOutput + "."
            phrase3 = "Est-ce que " + subjectOutput + ", c'est important pour vous?"
            phrase4 = "Quel role joue " + subjectOutput + "dans votre vie?"
            phrase5 = "Parlez-moi encore de " + subjectOutput + "."
        
        elif len(self.subjectInput) > 0 and self.verb != "": # on a le sujet ET le verbe
            #verbOutput = self.verb
            if len(self.verbtuple) > 0:
                verbOutput = self.conjugaison(self.verbtuple, self.subjectInput)
            
            
            subjectOutput = ""
            if len(self.subjectInput) > 1: #determinant + nom + eventuellement des adjectifs
                for i in range(len(self.subjectInput)):
                    self.subjectInput[i] = self.switchMe(self.subjectInput[i], self.myPronouns)
                    subjectOutput += self.subjectInput[i]
                    subjectOutput += " "
                subjectOutput.strip()
            else:
                if self.subjectInput[0] in ["tu", "t'", "vous"]:
                    self.output = random.choice(["Vous etes la pour parler de vous, pas de moi.", "On ne parle pas de moi ici.", "On est ici pour parler de vous."])
                    #res = self.output #-AJOUT MON 17
                    #self.res_fields() #-AJOUT MON 17
                    #return res #old
                    return self.output
                else:
                    subjectOutput = self.switchMe(self.subjectInput[0], self.myPronouns)
            
            if subjectOutput == "":
                self.output = self.defaultOutput()
                #res = self.output #-AJOUT MON 17
                #self.res_fields() #-AJOUT MON 17
                #return res #old
                return self.output

            if self.negation(self.tokenInput) == True:
                variability = ['Pourquoi ne ', 'Mais d\'après vous, pourquoi ne ', 'Je vois, mais selon vous, pourquoi ne ', 
                'Mais selon vous, pourquoi ne ', 'Et d\'après vous, pourquoi ne ', 'D\'accord, mais pourquoi ne ', 'Et pourquoi ne ',
                'Je vois, et selon vous, pourquoi ne ', 'Très bien, mais pourquoi ne ', 'Et selon vous, pourquoi ne ', 
                'Et en quoi ne ', 'Selon vous, en quoi ne ', 'D\'après vous, en quoi ne ']
                if subjectOutput in ['vous', 'ils', 'elles']:
                    self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif subjectOutput in ['il', 'elle']:
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['la', 'une', 'cette']:
                    subjectOutput = "elle"
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['le', 'un', 'cet', 'ce']:
                    subjectOutput = "il"
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['les', 'ces']: #pas de "des" car ambigu: article pl ou prep+article
                    subjectOutput = "ils"
                    self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                    
                else:
                    phrase1 = "Pourquoi dites-vous que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase2 = "Pourquoi pensez-vous que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase3 = "Qu'est ce que vous fait dire que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase4 = "Je vois, " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + ". Continuez, s'il vous plait."
                
                    self.output = random.choice([phrase1, phrase2, phrase3, phrase4])
            else:
                variability = ['Pourquoi ', 'Mais d\'après vous, pourquoi ', 'Je vois, mais selon vous, pourquoi ', 
                'Mais selon vous, pourquoi ', 'Et d\'après vous, pourquoi ', 'D\'accord, mais pourquoi ', 'Et pourquoi ',
                'Et en quoi ', 'Je vois, et selon vous, pourquoi ', 'Très bien, mais pourquoi ', 'Et selon vous, pourquoi ' 
                'Et en quoi ', 'Selon vous, en quoi ', 'D\'après vous, en quoi']
                if subjectOutput in ['vous', 'ils', 'elles']:
                    self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif subjectOutput in ['il', 'elle']:
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['la', 'une', 'cette']:
                    subjectOutput = "elle"
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['le', 'un', 'cet', 'ce']:
                    subjectOutput = "il"
                    if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                    else:
                        self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['les', 'ces']: #pas de "des" car ambigu: article pl ou prep+article
                    subjectOutput = "ils"
                    self.output = random.choice(variability) + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                
                else:
                    phrase1 = "Pourquoi dites-vous que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase2 = "Pourquoi pensez-vous que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase3 = "Qu'est ce que vous fait dire que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                    phrase4 = "Je vois, " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + ". Continuez, s'il vous plait."
                    
                    self.output = random.choice([phrase1, phrase2, phrase3, phrase4])
                
        if self.output == "":
            self.output = self.defaultOutput()
        
        return self.output
              
              
    
   

    def res_fields(self):
        self.input = ""
        self.tokenInput = []
        self.subjectInput = []
        self.objectInput = []
        self.verb = ""
        self.output = ""
        self.personResponse = ""
        self.objectResponse = ""      
    
    # nouvelle fonction qui gere des ambiguites dans lefff - Kira
    def prepare_flexion(self, flexion, subjectScope):
        if flexion[0] == 'Y': #si ca peut etre un imperatif
            flexion = flexion[1:]
        for i in range(len(flexion)):
            if flexion[i] == '1': 
                if i+1 < len(flexion):
                    if flexion[i+1] in ['2','3']: # si on a 12 ou 13 dans la flexion
                        for e in subjectScope:
                            if e in ['je', 'j\'']: #c'est la premiere personne
                                new_flexion = flexion[:i+1]
                                if i+2 < len(flexion):
                                    new_flexion += flexion[i+2:]
                                return new_flexion
                    
                        #sinon ce n'est pas la premiere personne
                        if i>0:
                            new_flexion = flexion[:i]
                        else:
                            new_flexion = []
                        
                        new_flexion += flexion[i+1:]
                        return new_flexion
        return flexion
                    
                    
    
  

   

 
 
    #def easter()
 
whatsTheWordHummingbird = [['Je vois et que représente',' ', 'pour vous?'], ['Pourquoi dites-vous que ',' ', " ? "], ["Et que pense ", " ", " de ceci ?"],
["Pourquoi pensez-vous que ", " ", " ?"], ["Qu'est-ce qui vous faire dire que ", " ", " ?"]]

talkToMeMore = ["Pourriez-vous m'en dire plus?", "Que voulez-vous dire?", "Pourriez-vous élaborer?", "Pourriez-vous développer sur ce sujet?", 
        "Que voulez-vous dire par là?", "Pourriez-vous m'en dire d'avantage?", "Qu'est-ce que cela veut dire pour vous?", "Ceci a-t-il un sens particulier pour vous?",
        "Et que ceci vous inspire-t-il?"]

allMyKeywords={'propriétaires?': 'human', 'familles?': 'human', 'fils': 'human', 'électricien.{0,3}': 'human', 'épou.{1,2}': 'human', 
'patron.{0,3}': 'human', 'voisin.{0,2}': 'human', 'frères?': 'human', 'soeurs?': 'human', 
'comptables?': 'human','copains?': 'human', 'femmes?': 'human', 'fromagers?': 'human', 
'belles?-filles?': 'human', 'maris?': 'human', 'diéticien.{0,3}': 'human', 'grands?-mères?': 'human', 
'beaux?-frères?': 'human', 'oncles?': 'human', 'belles?-mères?': 'human', 'potes?': 'human', 
'cousin.{0,2}': 'human', 'ami.{0,2}': 'human', 'élèves?': 'human', 'petits?-fils': 'human', 
'pédiatres?': 'human', 'femme de ménage': 'human', 'psychologues?': 'human', 'médecins?': 'human', 
'beaux?-fils': 'human', 'petites?-fille': 'human', 'plombiers?': 'human', 'collègues?': 'human', 
'architectes?': 'human', 'tantes?': 'human', 'boucher': 'human', 'père': 'human', 'psychiatres?': 'human', 
'belles?-soeurs?': 'human', 'petite?-amie?': 'human', 'copines?': 'human', 'beaux?-pères?': 'human', 
'grands?-pères?': 'human', 'filles?': 'human', 'boulanger': 'human', 'docteurs?': 'human', 'mère': 'human', 
'profs?': 'human', 'professeurs?': 'human', 'professions?':'obj', 'chats?': 'animal', 'chiens?': 'animal', 'poissons?': 'animal', 'poissons? rouges?': 'animal',
'voitures?': 'obj', 'maisons?': 'obj', 'travail': 'obj', 'jobs?': 'obj','métiers?': 'obj', 'enfants?': 'human', 'ordinateurs?':'obj',
'bureaux?': 'obj'}

psychoVerbs = {'haïr': 'Hate', 'aimer': 'Love',  'détester': 'Hate', 'adorer': 'Love',
'terroriser': 'NegFear', 'effrayer': 'NegFear' , 'alarmer': 'NegFear', 'terrifier': 'NegFear',
'paniquer': 'NegFear', 'intimider': 'NegFear', 'peiner': 'NegSad', 'attrister': 'NegSad',  
'inquiéter': 'NegFear', 'épouvanter': 'NegFear', 'angoisser': 'NegFear', 'abhorrer': 'Hate', 
'mépriser': 'Hate', 'dénigrer': 'Hate', 'paniquer': 'NegFear', 'jouir': 'Love', 'apprécier': 'Love', 
'stresser': 'NegFear', 'plaire': 'Love'}

myPronouns = {'je':'vous', 'j\'':'vous', 'me':'vous', 'm\'':'vous', 'moi':'vous', 'tu':'je', 'te':'me', 't\'':'me', 
'toi':'moi', 'nous':'vous', 'mien':'vôtre','tien':'mien', 'sien':'sien','mienne':'vôtre', 'tienne':'mienne', 
'sienne':'sienne', 'miens':'vôtres', 'tiens':'miens','siens':'siens','miennes':'vôtres', 'tiennes':'miennes', 
'siennes':'siennes','nôtre':'vôtre','vôtre':'mien', 'leur':'leur','nôtre':'vôtre', 'vôtre':'mienne','leur':'leur',
'nôtres':'vôtres','vôtres':'miennes', 'leurs':'leurs', 'ma':'votre', 'ta':'ma', 'mon':'votre', 'ton':'mon', 'mes':'vos', 
'notre':'votre', 'tes':'mes', 'votre':'mon', 'nos':'vos', 'vos':'mes'}

#reflexive = {'je me' : 'vous vous', 'je m\'' : 'vous vous', 'il se' : 'il se', 'il s\'' : 'il s\'', 'elle se' : 'elle se', 'elle s\'' : 'elle s\s'', 'nous nous' : 'vous vous', 'ils se' : 'ils se', 'ils s\'' : 'ils s\'', 'elles se' : 'elles se', 'elles s\'' : 'elles s\''}


reflexive = {'me' : 'vous', 'm\'' : 'vous', 'se' : 'se', 's\'' : 's\'', 'nous' : 'vous', 'te' : 'me', 't\'' : 'm\'', 'vous' : 'me'}

detPoss = {'ma':['votre'], 'mon':['votre'], 'un':['cet'], 'une':['cette'], 'des':['ces'], 'nos':['vos'], 'notre':['votre']}


