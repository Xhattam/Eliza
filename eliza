#!/bin/env python
# -*- coding: utf-8 -*-

import time
import random
import Tkinter
import re
import stack


"""
Created on Tue Apr 23 10:36:29 2013

@author: BAbemonty, MChassang, KKiranova, JTanon
"""
class eliza(): 

    def __init__(self):
    
       """
        @param String self.input                -   user entry from GUI
        @param str-List self.tokenInput         -   token list from user input   
        @param str-List self.subjectInput       -   token list for subject scope
        @param str-List self.objectInput        -   token list for object scope
        @param String self.verb                 -   identified verb
        @param str-Tuple self.verbtuple         -   tuple infinitif + flexion
        @param tuple-List self.stack            -   stack of keywords and objects (Eliza's memory)
        @param String self.output               -   calculated answer (to be sent back to GUI)  
        @param String-dict self.myPronouns      -   pronouns dictionary
        @param String-dict self.talkToMeMore    -   random sentence (if self.output is empty)
        @param String-dict self.psychoVerbs     -   psychological verbs dictionary
        @param String-dict self.allMyKeywords   -   keywords dictionary

        """

       
        self.input = "" 
        self.tokenInput = [] 
        self.subjectInput = []  
        self.objectInput = []  
        self.verb = ""  
        self.verbtuple = [] 
        self.stack = stack.stack()
        self.output = "" 
        self.refl_pro = "" #pronom reflechi eventuellement #AJOUTE 19/06 Kira
        self.myPronouns = myPronouns
        self.talkToMeMore = talkToMeMore
        self.psychoVerbs = psychoVerbs
        self.reflexive = reflexive
        self.allMyKeywords = allMyKeywords
    
    
    def setInput(self, text):
        """
        @param String text  -   user entry
        """
        
        self.input = text.encode('utf-8') # NEW tuesday 18
        


    def tokenize (self, entry):
        """
        @param String entry     -   user entry
        """
        
        s = entry
        token_list = []
        f = 1 # end of the token
        d = 0 # first symbol of the token
        elision = ['c', 'd', 'j', 'l', 'm', 'n', 's', 't'] # short words elided before an apostrophe, like me - m', ce - c'
        ponct = ['.', ',', '!', '?', ';', ':', '"', '(', ')', '[', ']']
        while f < len(s):
            word = ""
            sponct = "" 
            if(s[f] == " "):
                word = s[d:f]
                f += 1
                d = f
            elif(s[f] in ponct):
                sponct = s[f]
                word = s[d:f]
                if(f+1 < len(s)and s[f+1] == " "):
                    f += 2
                else:
                    f += 1
                d = f
            elif(s[f] == "'"): # if there's an apostrophe, it can be one word or two
                if(s[f-1].lower() in elision):
                    if(f-1 == 0): # first symbol of the phrase : it is an elided word
                        word = s[d:f+1]
                        f += 1
                        d = f
                    elif(s[f-2] ==" "): # first symbol of the word : it is an elided word
                        word = s[d:f+1]
                        f += 1
                        d = f
                    else: # it is a word with an apostrophe in the middle (like "aujourd'hui")
                        f += 1
                else: # not a lettre from the elision list : it can't be two words
                    f += 1
            else:
                f += 1
            
            if(word != ""):
                token_list.append(word)
            if(sponct != ""):
                token_list.append(sponct)
                
        if(d != len(s)): # if the last word is not in the token list, add it
            word = s[d:]
            token_list.append(word)
        
        if token_list[-1] in ponct:
            token_list = token_list[:-1] # on ne garde pas le point a la fin 
        
        self.tokenInput = token_list
          
    """
    def tagging(self):
         #etiquetage # MARINE
        lst = self.tokenInput
        posVerb = len(lst)-1
        pronouns = ['c\'', 'j\'', 'm\'', 'n\'', 's\'', 't\'', 'me', 'te', 'se', 'ne'] #precedent toujours un verbe
        for elem in range(len(lst)):
            for i in self.allMyKeywords:
                if re.match(i, lst[elem], re.I): #recherche avec regex
                    self.stackWrite(lst[elem]) #stakWrite prend un argu?? oui c'est push! 
                    # ECRIRE LES DETERMINANTS DANS LA PILE
        for i in range(len(lst)-1):
            if lst[i] in pronouns and lst[i+1][-2:] not in ["er", "ir"] and lst[i+1][-3:] not in ["ire", "dre", "tre"]: 
                self.verb = lst[i+1]
                posVerb = i+1
                break
        if self.verb == "":
            lefff = self.split_lefff()
            for e in range(len(lst)):
                in_lefff = self.recup_inf_rec(lefff, lst[e], 0, len(lefff)) #!! Renvoie toujours 'abaisser' !!
                if in_lefff != 0: # si verbe trouve dans Lefff # !! RECUPERE PREMIER ELEM DE TOKEN_LIST DS TOUS LES CAS !!
                    self.verb = lst[e] 
                    posVerb = e #TJR A ZERO
                    break
            if self.verb = "":
                return self.defaultOutput() - NEW MON 17 - update Kira
                
        #recherche de sujet
        subjectScope = lst[:posVerb]
        if len(subjectScope) > 0: # sinon donne index out of range - Kira
            self.searchSubject(subjectScope)
        
        
        #recherche d'objet
        idx = posVerb + 1
        if idx != len(lst):
            self.objectInput = lst[idx:]

        #return self.searchSubject(subjectScope) # il sert a quoi ce return? _ Il me semble qu'on l'a mis ici hier juste pour
        #faciliter l'appel de fonction consécutif pour faire passer l'input de départ, mais puisque ta fonction de calcul
        #de réponse fonctionne, y'en a plus besoin ;)

    """
    
    #NEW - ADDED WED 19
    def negation (self, t):
    lst1 = ["jamais", "rien", "ne", "n\'", "ni"]
	
	lst3 = ["pas", "plus", "point"]
	
	for e in t:
		if e in lst1 :
			return True
		elif e in lst3:
			for elem  in lst1:
				if elem in t:
					return True
	
    return False
    
    def tagging(self): #ma version de tagging - Kira
        #print "testtagg"
        lst = self.tokenInput
        #print lst
        # recherche de verbe
        posVerb = len(lst)-1
        
        #pronouns = ['c\'', 'j\'', 'm\'', 'n\'', 's\'', 't\'', 'me', 'te', 'se', 'ne'] #precedent toujours un verbe
        for elem in range(len(lst)):
            for i in self.allMyKeywords:
                if re.match(i, lst[elem]): #recherche avec regex
                    self.stackWrite(lst[elem]) #stakWrite prend un argu?? oui c'est push! 
                    # ECRIRE LES DETERMINANTS DANS LA PILE
        # for i in range(len(lst)-1): #sert a rien parce qu'on est obligé de chercher dans le Lefff pour pouvoir conjuguer
            #if lst[i] in pronouns and lst[i+1][-2:] not in ["er", "ir"] and lst[i+1][-3:] not in ["ire", "dre", "tre"]:
                # self.verb = lst[i+1]
                # posVerb = i+1
                # break
                
        if self.verb == "":
            lefff = self.split_lefff()
            for e in range(len(lst)):
                if lst[e] != 'tu': #sinon elle pense que tu est le participe passe de taire!
                    in_lefff = self.recup_inf(lefff, lst[e], lst[:e]) #troisieme argument - subjectScope - pour gerer la flexion. Kira
                    if in_lefff != 0: # si verbe trouve dans Lefff
                        self.verb = lst[e]
                        print "test"
                        print len(self.verb)
                        self.verbtuple = in_lefff #infinitif+flexion
                        print self.verb
                        print self.verbtuple
                        posVerb = e
                        
                        #AJOUTE 19/06 - Kira
                        if e > 1: #s'il y a au moins 2 mots avant le verbe alors il peut y avoir un pronom reflechi
                            if lst[e-1] in self.reflexive.keys():
                                if lst[e-1] == 'nous':
                                    for i in range(0,e-1):
                                        if lst[i] == 'nous':
                                            self.refl_pro = 'vous'
                                elif lst[e-1] == 'vous':
                                    for i in range(0,e-1):
                                        if lst[i] == 'vous':
                                            self.refl_pro = 'nous'
                                else:
                                    self.refl_pro = self.reflexive[lst[e-1]]
                        break
           
       
        #recherche de sujet
        subjectScope = lst[:posVerb]
        ponct = ['.', ',', '!', '?', ';', ':'] # elle ne doit pas penser que dans la phrase "Bonjour, je suis..." le sujet est "bonjour, je"
        newScope = subjectScope
        
        for i in range(len(subjectScope)):
            if subjectScope[i] in ponct:
                if i+1 < len(subjectScope):
                    newScope = subjectScope[i+1:]
                else:
                    newScope = []
        
        subjectScope = newScope
                
        
        #print subjectScope
        if len(subjectScope) > 0:
            self.searchSubject(subjectScope)
        
        
        
        #recherche d'objet
        idx = posVerb + 1
        if idx != len(lst):
            self.objectInput = lst[idx:]
           

    def searchSubject(self, subjectScope):
        lstPro = ['je$', 'tu$' 'ils?$', 'j\'$', 'elles?$', 'on$'] # les $ apres chaque mot servent a marquer que c'est la fin du mot. Sinon on trouve "lesssss" pour les?, "lac" pour la, "savoir" pour sa etc.
        for e in subjectScope:
            for pro in lstPro:
                if re.match(pro, e):
                    self.subjectInput.append(e)
                    return self.subjectInput
        return self.searchDet(subjectScope)

    
    def searchDet(self, subjectScope):
        length = len(subjectScope)-1
        elem = subjectScope[length] #-  !! ALWAYS OUT OF RANGE !! reglé - on n'appelle pas la fonction si subjectScope est vide - Kira
        pronouns = ['c\'', 'l\'', 'm\'', 'n\'', 's\'', 't\'', 'me', 'te', 'se', 'ne', 'la', 'le', 'les']
        lstDet = ['les?$', 'la$', 'une?$', 'des$', 'l\'$', 'mon$', 'ton$',
        'son$', 'ma$', 'ta$', 'sa$', 'mes$', 'tes$', 'ses$', 'nos$', 'vos$', 'leurs?$',
        'notre$', 'votre$', 'ce.{0,3}$', 'deux$', 'trois$', 'quatre$', 'cinq$', 'aucun.*',
        'tel.*', 'quelques?$', 'certain.*', 'divers.*', 'tou.{1,3}$']

        for e in range(len(subjectScope)):
            for det in lstDet:
                if re.match(det, subjectScope[e]):
                    if elem in pronouns:
                        self.subjectInput = subjectScope[e:length]
                    else:
                        self.subjectInput = subjectScope[e:length+1]
                    return self.subjectInput
        return self.subjectInput


    def defaultOutput(self):
        return random.choice(self.talkToMeMore)

    def getFinalAnswer(self): #reponse finale d'eliza
        """
        print self.subjectInput
        print self.objectInput
        print self.verb

        sentence = self.politeness()
        if sentence != None:
            sentence = "Eliza : testest"
        #if self.output == "":
            #self.defaultOutput()
        #return self.output 
            return sentence
        else:
            return "test"
        """
        # ma version - Kira - Super - reste plus qu'à gérer les cas ou y'a un mot vulgaire ou un verbe psycho, mais ça sera sûrement ailleurs, on voit ça mercredi!
        self.tokenize(self.input)
        self.tagging()
        self.setPhrase()
    
        return self.output
            
        #IMPORTANT!!!!!!! ajouter la remise a zéro!!!!!!!!

    #def returnFinal(self, sentence):


    def politeness(self): #politeness protocol 
        # will return a reminder in case a rude word is used - THIS IS TO BE CHECKED IN THE INPUT FIRST (so we don't use the lefff in case a rude word is used)
        rudeWords = ["chier","chie","chié","chiez","chiant","merde","sous-merde","emmerde","emmerdeur",
        "emmerdeuse","emmerdez","emmerder","conasse","connasse","conne","pétasse","poufiasse","grogniasse",
        "grognasse","abrutie","fiotte","connard","abruti","salopard","tasspe","sale porc","batard",
        "pute","putain", "salope","salop","salaud","pestifféré","con","couille", "bite", "cul", 
        "pédé","pd","tafiole","tapette","pédale","bordel","raclure","foutre","nique","niquer"]
        
        answers = ["Ne soyez pas grossier, s'il vous plait!", "Recentrez-vous sur votre objectif !",
        "Veillez à soigner votre langage !", "Vous semblez ne pas avoir compris le but de cette thérapie !",
        "Insulter ceux qui veulent vous aider ne vous mènera à rien !"]
        for words in sentence:
            if words in rudeWords:
                return random.choice(answers)
            else:
                break
        return self.input #if rude, we answer directly, otherwise we keep on calculating the answer.

    #Retourne element correspondant de p dans le dictionnaire dic
    def switchMe(self, p, dic): 
        if p in dic:
            return dic[p]
        else:
            return p

    #LEFFF
    def split_lefff (self):
    
        f = open("Lefff.txt", 'r') #Ouverture du fichier (lecture)
        texte = f.readline()
        lefff = []
    
        while texte != "":
            texte.strip
            sl = texte.split("\t")
            if len(sl) == 4: #sinon donne index out of range - Kira
                i = (sl[0], sl[1], sl[2], sl[3]) #Tuple :  0-Forme conjuguée, 1-v, 2-Infinitif, 3-Code flexion
                lefff.append(i)
            texte = f.readline()
        return lefff  
        
    
    def recup_inf (self, lefff, verbe, subjectScope):

        """Fonction qui recupere l'infinitif et la flexion du verbe en input
        @param lefff le lefff 'splitted' (e-List)
        @param verbe le verbe de l'input (e)
        @param subjectScope la partie de la phrase dans laquelle se trouve le sujet du verbe
        @return tuple infinitif+flexion (e-Tuple)
        """
        
        pos = 0
        while pos < len(lefff): #ici, on ne peut pas utiliser la recherche dichotomique a cause des verbes irreguliers (suis - etre : loin dans l'alphabet)
                verbform = lefff[pos]
                if verbe == verbform[0]:
                    return (verbform[2], self.prepare_flexion(verbform[3], subjectScope))
                pos += 1
        return 0
        
        #return self.recup_inf_rec(lefff, verbe, 0, len(lefff), subjectScope)
        
        
    def recup_inf_rec(self, lefff, verbe, debut, fin, subjectScope): #fonction recursive
        # recherche dichotomique
        
        while debut < fin:

            m = (debut+fin)/2;
            val = lefff[m]
            
            if(val[0] == verbe):
                return (val[2], val[3])
            elif(val[0] > verbe):
                return self.recup_inf_rec(lefff, verbe, debut, m, subjectScope)
            else:
                return self.recup_inf_rec(lefff, verbe, m+1, fin, subjectScope)
            
        return 0
        
    
    
    def flexion (self, f):
        
        """ Fonction qui determine la flexion de l'output
        @param f tuple infinitif+flexion (e-Tuple)
        @return f[1] la flexion de l'output (e)
        @return la flexion de l'output (e)"""

        if f[1] in ["Ps1\n", "PSs1\n"]:
            return "Pp2\n" #Pp2 et pas P2p - Kira
        if f[1] == "Fs1\n":
            return "Fp2\n"
        if f[1] == "Is2\n":
            return "Ip2\n"
        if f[1] == "Js2\n":
            return "Jp2\n"
        if f[1] == "Ss1\n":
            return "Sp1\n"
        if f[1] == "Ts1\n":
            return "Tp1\n"
        if f[1] == "PSp3\n": 
            return "PSp3\n"
        if f[1] == "PSp1\n":
            return "PSp2\n"
        if f[1] == "Cs12\n":
            return "Cp2\n"
        if f[1] == "Is12\n":
            return "Ip2\n"
        if f[1] == "PSs13\n":
            return "PSs13\n"
        if f[1] == "Ps13\n":
            return "Ps13\n"
        if f[1] == "YPs1\n":
            return "Pp2\n"
        if f[1] == "YPp1\n":
            return "YPp2\n"
        return f[1]


    def conjugaison (self, verbtuple, subjectScope):

        """ Fonction qui renvoie le verbe conjugue pour l'output
        @param t_inf_flex tuple infinitif+flexion output (e-Tuple)
        @param lefff le lefff "splited" (e-List)
        @param subjectScope la partie de la phrase ou se trouve le sujet du verbe
        @return le verbe conjugue (e)"""
        
        """
        s = self.verb
        f = split_lefff()
        v = recup_inf (f, s)
        t_inf_flex = (v[0], flexion(v))
        pos = 0
        while pos < len(lefff):
            if lefff[pos][2] == t_inf_flex[0] and lefff[pos][3] == t_inf_flex[1]:
                return lefff[pos][0]
            pos = pos + 1
        return talkToMeMore()
        """
        
        #version modifiee - Kira
        print verbtuple
        flexion = self.flexion(verbtuple)
        if flexion != verbtuple[1]: #evite de parcourir le Leff si la forme du verbe ne change pas
            lefff = self.split_lefff()
            pos = 0
            while pos < len(lefff): #ici, on ne peut pas utiliser la recherche dichotomique a cause des verbes irreguliers (suis - etre : loin dans l'alphabet)
                verbform = lefff[pos]
                if verbform[2] == verbtuple[0] and self.prepare_flexion(verbform[3],subjectScope) == flexion:
                    self.verb = verbform[0]
                    return self.verb
                pos += 1
        
        return self.verb

    
    def stackRead(self): #lecture de la pile # MARINE
        return self.stack.pop()
    
    def stackWrite(self, s): #ecriture de la pile # MARINE
        self.stack.push(s)
        
def setPhrase(self): # fonction qui genere l'output
        #print self.subjectInput
        determinants = ['un', 'une', 'la', 'le', 'les', 'l\'', 'des', 'ma', 'ta', 'sa', 'mon', 'ton', 'son', 'mes', 'tes', 'ses', 'nos', 'vos', 'leur', 'leurs', 'notre', 'votre']
        objectOutput = ""
        for e in range(len(self.objectInput)): #on change je-vous dans l'objet et on le transforme en chaine de caracteres
            self.objectInput[e] = self.switchMe(self.objectInput[e], self.myPronouns)
            objectOutput += self.objectInput[e]
            objectOutput += " "
        objectOutput.strip()
        
        if self.verb == "" and len(self.subjectInput) == 0: # si on a rien, on cherche des mots-cles dans l'objet
            for i in range(len(self.objectInput)):
                word = self.objectInput[i]
                for key in allMyKeywords.keys():
                    if re.match(key, word):
                        if allMyKeywords[word] == 'human':
                            wordOutput = "cette personne"
                            if i > 0 and self.objectInput[i-1] in determinants:
                                det = self.switchMe(self.objectInput[i-1])
                                wordOutput = det
                                wordOutput += " "
                                wordOutput += word
                            
                            phrase1 = "Je vois, et que représente " + wordOutput + " pour vous?"
                            phrase2 = "Passez-vous beaucoup de temps avec " + wordOutput + "?"
                            phrase3 = "Et que pense " + wordOutput + "de ceci?"
                            phrase4 = "Vous en avez parlé avec " + wordOutput + "?"
                            phrase5 = "Parlez-moi encore de " + wordOutput + "."
                            phrase6 = "Parlez-moi de vos relations avec " + wordOutput + "."
                            self.output = random.choice([phrase1, phrase2, phrase3, phrase4, phrase5, phrase6])
                            #res = self.output
                            #self.res_fields() #-AJOUT MON 17
                            #return res #old -
                            return self.output
                        else:
                            wordOutput = "cela"
                            if i > 0 and self.objectInput[i-1] in determinants:
                                det = self.switchMe(self.objectInput[i-1])
                                wordOutput = det
                                wordOutput += " "
                                wordOutput += word
                                
                            phrase1 = "Je vois, et que représente " + wordOutput + " pour vous?"
                            phrase2 = "Parlez-moi plus de " + wordOutput + "."
                            phrase3 = "Est-ce que " + wordOutput + ", c'est important pour vous?"
                            phrase4 = "Quel role joue " + wordOutput + "dans votre vie?"
                            self.output = random.choice([phrase1, phrase2, phrase3, phrase4])
                            #res = self.output #-AJOUT MON 17
                            #self.res_fields() #-AJOUT MON 17
                            #return res #old
                            return self.output
                        
            if self.stack.size() > 0: # sinon on prend de la pile
                memory = self.stackRead() #NEW - ajouter un det ici, non? Comme "votre chat"? oui mais pour ca il faut que le nom dans la pile soit avec son det
                phrase1 = "Revenons a " + memory + ". Pourriez-vous m'en parlez plus?"
                phrase2 = "Parlez-moi plus de " + memory + ", s'il vous plait."
                phrase3 = "Parlez-moi encore de " + memory + ", c'est important pour vous?"
                self.output = random.choice([phrase1, phrase2, phrase3])
                #res = self.output #-AJOUT MON 17
                #self.res_fields() #-AJOUT MON 17
                #return res #old
                return self.output
            else:
                self.output = self.defaultOutput()
                #res = self.output #-AJOUT MON 17
                #self.res_fields() #-AJOUT MON 17
                #return res #old
                return self.output
        
        elif self.verb == "" and len(self.subjectInput) > 0: #si on a le sujet mais pas le verbe
            subjectOutput = ""
            if len(self.subjectInput) > 1: #determinant + nom + eventuellement des adjectifs
                for i in range(len(self.subjectInput)):
                    self.subjectInput[i] = self.switchMe(self.subjectInput[i], self.myPronouns)
                    subjectOutput += self.subjectInput[i]
                    subjectOutput += " "
                subjectOutput.strip()
            else:
                if self.subjectInput[0] in ["tu", "t'", "vous"]:
                    self.output = random.choice(["Vous etes la pour parler de vous, pas de moi.", "On ne parle pas de moi ici.", "On est ici pour parler de vous."])
                    return self.output
                elif self.subjectInput[0] in ["je", "j'", "nous"]:
                    self.output = random.choice(["Parlez-moi plus de vous, s'il vous plait.", "C'est important, continuez.", "Parlez-moi davantage sur votre vie.", "Parlez-moi de vos relations avec les autres."])
                    #res = self.output #-AJOUT MON 17
                    #self.res_fields() #-AJOUT MON 17
                    #return res #old
                    return self.output
                else:
                    subjectOutput = self.switchMe(self.subjectInput[0], self.myPronouns)
            
            if subjectOutput == "":
                self.output = self.defaultOutput()
                #res = self.output #-AJOUT MON 17
                #self.res_fields() #-AJOUT MON 17
                #return res #old
                return self.output
                
            
            phrase1 = "Je vois, et que représente " + subjectOutput + " pour vous?"
            phrase2 = "Parlez-moi plus de " + subjectOutput + "."
            phrase3 = "Est-ce que " + subjectOutput + ", c'est important pour vous?"
            phrase4 = "Quel role joue " + subjectOutput + "dans votre vie?"
            phrase5 = "Parlez-moi encore de " + subjectOutput + "."
        
        elif len(self.subjectInput) > 0 and self.verb != "": # on a le sujet ET le verbe
            verbOutput = self.verb
            if len(self.verbtuple) > 0:
                verbOutput = self.conjugaison(self.verbtuple, self.subjectInput)
            
            
            subjectOutput = ""
            if len(self.subjectInput) > 1: #determinant + nom + eventuellement des adjectifs
                for i in range(len(self.subjectInput)):
                    self.subjectInput[i] = self.switchMe(self.subjectInput[i], self.myPronouns)
                    subjectOutput += self.subjectInput[i]
                    subjectOutput += " "
                subjectOutput.strip()
            else:
                if self.subjectInput[0] in ["tu", "t'", "vous"]:
                    self.output = random.choice(["Vous etes la pour parler de vous, pas de moi.", "On ne parle pas de moi ici.", "On est ici pour parler de vous."])
                    #res = self.output #-AJOUT MON 17
                    #self.res_fields() #-AJOUT MON 17
                    #return res #old
                    return self.output
                else:
                    subjectOutput = self.switchMe(self.subjectInput[0], self.myPronouns)
            
            if subjectOutput == "":
                self.output = self.defaultOutput()
                #res = self.output #-AJOUT MON 17
                #self.res_fields() #-AJOUT MON 17
                #return res #old
                return self.output
            
            if subjectOutput in ['vous', 'ils', 'elles']:
                self.output = "Pourquoi " + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
            elif subjectOutput in ['il', 'elle']:
                if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                    self.output = "Pourquoi " + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                else:
                    self.output = "Pourquoi " + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
            elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['la', 'une', 'cette']:
                subjectOutput = "elle"
                if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                    self.output = "Pourquoi " + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                else:
                    self.output = "Pourquoi " + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
            elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['le', 'un', 'cet', 'ce']:
                subjectOutput = "il"
                if verbOutput[-1] in ['a', 'e', 'o', 'u', 'i']:
                    self.output = "Pourquoi " + self.refl_pro + " " + verbOutput + "-t-" + subjectOutput + " " + objectOutput + "?"
                else:
                    self.output = "Pourquoi " + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
            elif len(self.subjectInput) > 1 and self.subjectInput[0] in ['les', 'ces']: #pas de "des" car ambigu: article pl ou prep+article
                subjectOutput = "ils"
                self.output = "Pourquoi " + self.refl_pro + " " + verbOutput + "-" + subjectOutput + " " + objectOutput + "?"
                
            else:        
                phrase1 = "Pourquoi dites-vous que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                phrase2 = "Pourquoi pensez-vous que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                phrase3 = "Qu'est ce que vous fait dire que " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + "?"
                phrase4 = "Je vois, " + subjectOutput + self.refl_pro + " " + verbOutput + " " + objectOutput + ". Continuez, s'l vous plait."
                
                self.output = random.choice([phrase1, phrase2, phrase3, phrase4])
                
        if self.output == "":
            self.output = self.defaultOutput()
        
        #res = self.output #-AJOUT MON 17
        #self.res_fields() #-AJOUT MON 17
        #return res #old return self.output
        return self.output
              
    
    def psycho(self):
        verb = self.recup_inf(self.verb)
        if verb in self.psychoVerbs:
            if self.psychoVerbs[verb] == 'NeutralSurprise':
                print 'En quoi cela vous verb-t-il ?'
                print 'Pourquoi ceci vous verb-t-il ?'
            elif self.psychoVerbs[verb] == 'NegFear':
                print 'Pourquoi vous sentez-vous ...'
                print 'Qu\'est-ce qui vous fait vous sentir'
            elif self.psychoVerbs[verb] == 'LoveHate':
                if self.obj in humans:
                    print 'Pourquoi self.verb-vous \'blabla\' ?'
                    print 'Qu\'est-ce que vous self.verb chez \'blabla\' ?'
                if self.obj in animal:
                    print 'Dites-moi pouquoi vous verb \'blabla\' ?'
                    print 'Pourquoi verb-vous cet \'blabla\' ?'
                elif self.obj in obj:
                    print 'Et que pensez-vous de ceci ?'
                    print 'Et que ceci vous inspire-t-il ?'
            elif self.psychoVerbs[verb] == 'PosSurprise':
                print 'C\'est bien! Dites m\'en plus!'
                print 'C\'est très bien, j\'aimerais en savoir plus, dites-moi donc!'
            elif self.psychoVerbs[verb] == 'PosSensitive':
                print 'Pourquoi ceci vous verb-t-il?'
                print 'Dites-moi en quoi ceci vous verb'
            elif self.psychoVerbs[verb] == 'NegSad':
                print 'Pourquoi pensez-vous que \'blabla\' a un rapport avec vos problèmes?'
                print 'Pourquoi \'machin\' vous verb-t-il?'
            else:
                return verb
        else:
            self.verb
        return verb

    def keyWords(self):
        pass

    def res_fields(self):
        self.input = ""
        self.tokenInput = []
        self.subjectInput = []
        self.objectInput = []
        self.verb = ""
        #if self.stack.isFull():
            #val = self.stack.pop()
            #self.stack.restet()
            #self.stack.push(val)
        self.subjectResponse = "" - NEVER USED DELETE
        self.output = ""
        self.personResponse = ""
        self.objectResponse = ""      
    
    # nouvelle fonction qui gere des ambiguites dans lefff - Kira
    def prepare_flexion(self, flexion, subjectScope):
        if flexion[0] == 'Y': #si ca peut etre un imperatif
            flexion = flexion[1:]
        for i in range(len(flexion)):
            if flexion[i] == '1': 
                if i+1 < len(flexion):
                    if flexion[i+1] in ['2','3']: # si on a 12 ou 13 dans la flexion
                        for e in subjectScope:
                            if e in ['je', 'j\'']: #c'est la premiere personne
                                new_flexion = flexion[:i+1]
                                if i+2 < len(flexion):
                                    new_flexion += flexion[i+2:]
                                return new_flexion
                    
                        #sinon ce n'est pas la premiere personne
                        if i>0:
                            new_flexion = flexion[:i]
                        else:
                            new_flexion = []
                        
                        new_flexion += flexion[i+1:]
                        return new_flexion
        return flexion
                    
                    
    
    #def setPhrase(): #phrases a trous - KIRA - Liste correspondante: whatsTheWordHummingbird 
        #On va te donner les phrases

    #def subjectCorrespondance(): #pronoms sujet # BENJAMIN
        #Doit definir self.personInput
        #A troisieme personne par defaultm sauf si pronom perso

    #COD, COI, possessifs reflexifs # BENJAMIN

    ###def verbIdentification(): # reconnaissance du verbe # BENJAMIN
    #def negation(): #Benjamin
        #ne, pas, jamais, ni, "n\'"
    
    ###def lefff(): #fichier + champs verb # BENJAMIN

    
    #def politeness(): #protocole de politesse # JESSICA
        #liste de mots vulgaires

   

 
 
    #def easter()
 
whatsTheWordHummingbird = [['Je vois et que représente',' ', 'pour vous?'], ['Pourquoi dites-vous que ',' ', " ? "], ["Et que pense ", " ", " de ceci ?"],
["Pourquoi pensez-vous que ", " ", " ?"], ["Qu'est-ce qui vous faire dire que ", " ", " ?"]]

talkToMeMore = ["Pourriez-vous m'en dire plus?", "Que voulez-vous dire?", "Pourriez-vous élaborer?", "Pourriez-vous développer sur ce sujet?", 
        "Que voulez-vous dire par là?", "Pourriez-vous m'en dire d'avantage?", "Qu'est-ce que cela veut dire pour vous?", "Ceci a-t-il un sens particulier pour vous?",
        "Et que ceci vous inspire-t-il?"]

allMyKeywords={'propriétaires?': 'human', 'familles?': 'human', 'fils': 'human', 'électricien.{0,3}': 'human', 'épou.{1,2}': 'human', 
'patron.{0,3}': 'human', 'voisin.{0,2}': 'human', 'frères?': 'human', 'soeurs?': 'human', 
'comptables?': 'human','copains?': 'human', 'femmes?': 'human', 'fromagers?': 'human', 
'belles?-filles?': 'human', 'maris?': 'human', 'diéticien.{0,3}': 'human', 'grands?-mères?': 'human', 
'beaux?-frères?': 'human', 'oncles?': 'human', 'belles?-mères?': 'human', 'potes?': 'human', 
'cousin.{0,2}': 'human', 'ami.{0,2}': 'human', 'élèves?': 'human', 'petits?-fils': 'human', 
'pédiatres?': 'human', 'femme de ménage': 'human', 'psychologues?': 'human', 'médecins?': 'human', 
'beaux?-fils': 'human', 'petites?-fille': 'human', 'plombiers?': 'human', 'collègues?': 'human', 
'architectes?': 'human', 'tantes?': 'human', 'boucher': 'human', 'père': 'human', 'psychiatres?': 'human', 
'belles?-soeurs?': 'human', 'petite?-amie?': 'human', 'copines?': 'human', 'beaux?-pères?': 'human', 
'grands?-pères?': 'human', 'filles?': 'human', 'boulanger': 'human', 'docteurs?': 'human', 'mère': 'human', 
'profs?': 'human', 'professeurs?': 'human', 'professions?':'obj', 'chats?': 'animal', 'chiens?': 'animal', 'poissons?': 'animal', 'poissons? rouges?': 'animal',
'voitures?': 'obj', 'maisons?': 'obj', 'travail': 'obj', 'jobs?': 'obj','métiers?': 'obj', 'enfants?': 'human', 'ordinateurs?':'obj',
'bureaux?': 'obj'}

psychoVerbs = {'plaire': 'PosSurprise', 'déplaire': 'NegSad', 'ébahir': 'NeutralSurprise', 'surprendre': 'NeutralSurprise', 'souffler': 'NeutralSurprise', 'terroriser': 'NegFear', 'éblouir': 'PosSurprise', 
'renverser': 'NeutralSurprise', 'admirer': 'NeutralSurprise', 'effrayer': 'NegFear', 'attrister': 'NegSad', 'haïr': 'LoveHate', 'aimer': 'LoveHate', 
'interdire': 'NeutralSurprise', 'étonner': 'NeutralSurprise', 'interloquer': 'NeutralSurprise', 'émotionner': 'PosSensitive', 
'stupéfier': 'NeutralSurprise', 'chiffonner': 'NegSad', 'méduser': 'NeutralSurprise', 'désoler': 'NegSad', 'épater': 'NeutralSurprise', 'détester': 'LoveHate', 
'troubler': 'PosSensitive', 'remuer': 'PosSensitive', 'abasourdir': 'NeutralSurprise', 'effaroucher': 'NegFear', 'intimider': 'NegFear',
'peiner': 'NegSad', 'ébaubir': 'NeutralSurprise', 'saisir': 'NeutralSurprise', 'estomaquer': 'NeutralSurprise', 'ahurir': 'NeutralSurprise', 'adorer': 'LoveHate',
'terrifier': 'NegFear', 'amuser': 'PosSensitive', 'affoler': 'NegFear', 'apeurer': 'NegFear', 'alarmer': 'NegFear', 'rembrunir': 'NegSad', 
'chavirer': 'PosSensitive', 'paniquer': 'NegFear', 'affecter': 'NegSad', 'toucher': 'PosSensitive', 'chagriner': 'NegSad', 'confondre': 'NeutralSurprise', 
'tournebouler': 'PosSensitive', 'atteindre': 'NegSad', 'contrarier': 'NegSad', 'affliger': 'NegSad', 'époustoufler': 'NeutralSurprise', 'glacer': 'NegFear', 
'horrifier': 'NegFear', 'frapper': 'NeutralSurprise', 'scier': 'NeutralSurprise', 'bouleverser': 'PosSensitive', 
'émouvoir': 'PosSensitive', 'chambouler': 'PosSensitive', 'inquiéter': 'NegFear', 'émerveiller': 'PosSurprise', 'épouvanter': 'NegFear', 'angoisser': 'NegFear', 
'assombrir': 'NegSad', 'navrer': 'NegSad', 'ébouriffer': 'NeutralSurprise', 'sidérer': 'NeutralSurprise', 'préoccuper': 'NegSad', 'dégoûter': 'NegSad' }   


myPronouns = {'je':'vous', 'j\'':'vous', 'me':'vous', 'm\'':'vous', 'moi':'vous', 'tu':'je', 'te':'me', 't\'':'me', 
'toi':'moi', 'nous':'vous', 'mien':'vôtre','tien':'mien', 'sien':'sien','mienne':'vôtre', 'tienne':'mienne', 
'sienne':'sienne', 'miens':'vôtres', 'tiens':'miens','siens':'siens','miennes':'vôtres', 'tiennes':'miennes', 
'siennes':'siennes','nôtre':'vôtre','vôtre':'mien', 'leur':'leur','nôtre':'vôtre', 'vôtre':'mienne','leur':'leur',
'nôtres':'vôtres','vôtres':'miennes', 'leurs':'leurs', 'ma':'votre', 'ta':'ma', 'mon':'votre', 'ton':'mon', 'mes':'vos', 
'notre':'votre', 'tes':'mes', 'votre':'mon', 'nos':'vos', 'vos':'mes'}

#reflexive = {'je me' : 'vous vous', 'je m\'' : 'vous vous', 'il se' : 'il se', 'il s\'' : 'il s\'', 'elle se' : 'elle se', 'elle s\'' : 'elle s\s'', 'nous nous' : 'vous vous', 'ils se' : 'ils se', 'ils s\'' : 'ils s\'', 'elles se' : 'elles se', 'elles s\'' : 'elles s\''}


reflexive = {'me' : 'vous', 'm\'' : 'vous', 'se' : 'se', 's\'' : 's\'', 'nous' : 'vous', 'te' : 'me', 't\'' : 'm\'', 'vous' : 'me'}

detPoss = det = {'ma':['votre'], 'mon':['votre'], 'un':['cet'], 'une':['cette'], 'des':['ces'], 'nos':['vos'], 'notre':['votre']}


